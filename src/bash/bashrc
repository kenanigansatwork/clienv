# ~/.bashrc
# shellcheck shell=bash

{ # helper variables and functions

    [[ ! -e ~/.hushlogin ]] && echo -n > ~/.hushlogin

    export CLR_SUCCESS_HEADER=$'\033[42;37;1m'
    export CLR_ERR_HEADER=$'\033[41;37;1m'
    export CLR_ERR_TXT=$'\033[31;1m'
    export CLR_RST=$'\033[00m'

    if [[ -z "${DEBUG_LEVEL:-}" ]]; then
        declare -ix DEBUG_LEVEL
        DEBUG_LEVEL=-2
    fi
    (( DEBUG_LEVEL > -2 )) && printf '[DEBUG_LEVEL: %d]\n' "${DEBUG_LEVEL}"

    function _err () {
        local msg header;
        msg="${*:-"an unspecified error occurred"}";
        header=" ERROR ";
        printf '  %s[ %s ]%s: %s%s%s\n' \
            "${CLR_ERR_HEADER}" "${header}" "${CLR_RST}" \
            "${CLR_ERR_TXT}" "${msg}" "${CLR_RST}" >&2;
        return 0
    }
    function _success () {
        local msg header;
        msg="${*:?}";
        header="SUCCESS";
        printf '  %s[ %s ]%s: %s\n' "${CLR_SUCCESS_HEADER}" "${header}" "${CLR_RST}" "${msg}" >&2;
        return 0
    }
    function _isMac () { if [[ "$(uname)" == 'Darwin' ]]; then return 0; fi; return 1; }
    function _hasCommand () { local TARGET; TARGET="${1:?}"; if command -v "${TARGET}" &> /dev/null; then return 0; fi; return 1; }

    if _isMac && _hasCommand system_profiler; then
        function _sysinfo () 
        { 
            local -i DEBUG; DEBUG=0;
            if [[ "${1:-}" =~ (-|--)?(D|DEBUG|debug)$ ]];
            then
                DEBUG=1; shift 1;
            fi;
            tmpfile="$(mktemp)";
            builtin trap '(( DEBUG == 1 )) && /usr/bin/printf "removing temp file (${tmpfile})... "; if /bin/rm "${tmpfile}"; then (( DEBUG == 1 )) && /bin/echo SUCCESS; else (( DEBUG == 1 )) && /bin/echo FAILED; fi;' RETURN;
            (( DEBUG == 1 )) && /usr/bin/printf '\n  > [DEBUG]: TEMPFILE -- %s\n\n' "${tmpfile}";
            /usr/sbin/system_profiler -detailLevel mini -xml SPSoftwareDataType > "${tmpfile}";
            /usr/bin/plutil -p "${tmpfile}" | /usr/bin/sed -n '/^[[:blank:]]*"_name"/,/^[[:blank:]]*"uptime"/p' | /usr/bin/tr -d '"' | /usr/bin/sed 's/^[[:blank:]][[:blank:]]*_*\([^[:blank:]]*\)  *=>  *\(.*$\)/\1|\2/' | /usr/bin/awk -F"|" 'BEGIN{printf "\nSYSTEM INFO:\n"}{printf ("- %*s %s\n",-15,$1":",$2)}';
            builtin echo;
            return
        }
    fi
}

{ # ENVIRONMENTAL VARIABLES
    _isMac && export GLOBIGNORE=.DS_Store:.CFUserTextEncoding:.localized:.hushlogin
    export CDPATH=.:~
    export LSCOLORS=$'Dxfxcxdxbxegedabagacad';      # default =. 'exfxcxdxbxegedabagacad'
    export HISTFILE=~/.bash_history
    export HISTFILESIZE=100000
    export HISTSIZE=100000
    export HISTCONTROL='ignoreboth'
    export MYSQL_HISTFILE=~/.mysql_history
    export LESSHISTFILE=~/.less_history
    export LESSHISTSIZE=10000
    export EDITOR='vim'

    if ! echo "$PATH" | grep -q "/usr/local/sbin"
    then
        export PATH="${PATH:+"${PATH}:"}/usr/local/sbin"
    fi

    { # SET PROMPT VARIABLE (PS1)

        if ((EUID == 0)); then
            # set root prompt
            export PS1=$'\[\e[41;37;1m[\u]\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
        else
            export PS1=$'[\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
        fi
    }

    { # SET PROMPT_COMMAND
    
        unset -f ps1_command

        function ps1_command() {
            local -ir xit=$?;
            if (( xit != 0 )); then
                echo
                _err "=> $(history 1 | sed 's:^[[:blank:]]*[0-9][0-9]*[[:blank:]]*\(.*$\):\1:')";
                echo
            fi
            return ${xit}
        }

        if ! echo "${PROMPT_COMMAND}" | grep -q 'ps1_command'; then
            PROMPT_COMMAND='ps1_command'"${PROMPT_COMMAND:+";${PROMPT_COMMAND}"}"
        fi

    }

    { # LOCATION VARIABLES
        if [[ -n "${_location_variables[*]}" ]]; then
            # unset all location variables
            for key in "${!_location_variables[@]}"; do
                unset "${key}"
            done
        fi
        unset _location_variables
        
        declare -A _location_variables; _location_variables=()
        declare -A _location_variable_errors; _location_variable_errors=()

        function validateAndSetLocationVariables() {
            local NAME DIR;
            NAME="${1:?}" DIR="${2:?}"
            if [[ ! -d "${DIR}" ]]; then
                _location_variable_errors["${NAME}"]="${DIR}"
                (( DEBUG_LEVEL >= -1 )) && _err "unable to set variable. directory not found -- ${DIR}"
                return 1
            fi
            if [[ -n "${!NAME}" ]]; then
                _location_variable_errors["${NAME}"]="${DIR}"
                (( DEBUG_LEVEL >= 0 )) && _err "name has already been set previously -- ${!NAME}"
                return 2
            fi
            eval "${NAME}=\"${DIR}\""
            if [[ -n "${!NAME}" && "${!NAME}" == "${DIR}" ]]; then
                _location_variables["${NAME}"]="${DIR}"
                (( DEBUG_LEVEL == 1 )) && _success "${NAME} => ${!NAME}"
            fi
        }

        { # set location variables here
            (( DEBUG_LEVEL >= 0 )) && printf '\n  [%s] => %s\n\n' 'clienv' 'setting location variables';
            if _isMac; then
                validateAndSetLocationVariables "clienv" ~/Desktop/clienv
                validateAndSetLocationVariables "dev" ~/Developer
                validateAndSetLocationVariables "repos" ~/Developer/repos
                validateAndSetLocationVariables "desk" ~/Desktop
                validateAndSetLocationVariables "docs" ~/Documentssssss
                validateAndSetLocationVariables "dl" ~/Downloads
                validateAndSetLocationVariables "sites" ~/Sites
                validateAndSetLocationVariables "favs" ~/Library/Favorites/
                validateAndSetLocationVariables "proj" ~/Projects
                validateAndSetLocationVariables "var" /private/var
                validateAndSetLocationVariables "etc" /private/etc
                validateAndSetLocationVariables "uvar" /usr/local/var
                validateAndSetLocationVariables "uetc" /usr/local/etc
                validateAndSetLocationVariables "uetc2" /usr/local/etcc
                validateAndSetLocationVariables "uetc" /usr/local/
            fi
        }

	shopt -s cdable_vars

        if (( ${#_location_variable_errors[@]} > 0 )); then
            (( DEBUG_LEVEL >= 0 )) && _err "location variable assignment errors occurred (${#_location_variable_errors[@]})"
        fi
        
        # clean up
        unset -f validateAndSetLocationVariables
        unset _location_variable_errors
    }
}

{ # USER ALIASES

    #shellcheck disable=2015
    _isMac && alias ls='ls -hGTtx' || alias ls='ls --color=auto'

    alias la='ls -A'
    alias ll='ls -og'
    alias lla='ls -ogA'
    alias l1='ls -1'
    alias lm='ls -m'
    alias l.='ls -d .[^$.]* 2> /dev/null'
    alias ll.='ls -ogd .[^$.]* 2> /dev/null'
    alias l1.='ls -1d .[^$.]* 2> /dev/null'
    alias lm.='ls -md .[^$.]* 2> /dev/null'

    alias c='clear'
    alias x='exit'
    alias sbash='[ -r ~/.bash_profile ] && . ~/.bash_profile'

    alias grep='/usr/bin/grep --color=auto'
    alias egrep='/usr/bin/egrep --color=auto'
    alias fgrep='/usr/bin/fgrep --color=auto'

    alias mkdir='mkdir -p'

}


f1 () {
    target="${1:?}"; shift 1
    local -a args
    args=([0]='-mindepth' [1]=1 [2]='-maxdepth' [3]=1)
    args+=( "$@" )
    CMD="command find ${target}"
    for ((c=0;c<${#args[@]};c++)); do
        CMD+=" $(printf '%q' "${args[${c}]}")"
    done
    #echo "CMD: ${CMD}"
    eval "${CMD}"
    return
}

function hr () {
    local -i OPTIND rtstrlength; OPTIND=1; rtstrlength=4
    local -i col; col=${COLUMNS:-$(tput cols)}
    local hrstr delim headertext; hrstr=''; delim='_'; headertext='';
    (( ${#delim} > 1 )) && delim="${delim:0:1}"
    while getopts :d:h:PD OPT
    do
        case "${OPT}" in
            d) delim="${OPTARG:0:1}"
            ;;
            D)
                # include date
                headertext="$(date +"%a %H:%M")"
            ;;
            P)
                # include $PWD
                headertext="${PWD}"
            ;;
            h) headertext="${OPTARG}"
            ;;
            :) _err "flag requires an argument -- ${OPTARG}"
            ;;
            *) _err "invalid option flag -- ${OPTARG}"
            ;;
        esac
    done; shift $((OPTIND-1))
    local text; text=''
    if [[ -z "${headertext:-}" ]]; then
        if (( $# > 0 )) ; then
            text="${*}";
        fi
    else
        text="${headertext}"
    fi
    (( ${#text} > col )) && { _err; return 2; }
    for (( c = 0; c < $(( col - ${#text} - $((rtstrlength+2)) )); c++ )); do
        hrstr="${hrstr}${delim}"
    done
    if [[ -n "${text:-}" ]]; then hrstr+="[${text}]"
    else hrstr+="${delim}${delim}"
    fi
    for (( a = 0; a < rtstrlength; a++ )); do
        hrstr+="${delim}"
    done
    (( ${#hrstr} != col )) && { _err; return 1; }
    printf '%s\n' "${hrstr}"
    return
}

function funcs () {

    #shellcheck disable=2207
    declare -F | sed -E 's/^declare -[a-z0-1A-Z]+ //' | sort | grep -v '^shell_session_'
    mapfile FUNCNAMES < <(declare -F | sed -E 's/^declare -[a-z0-1A-Z]+ //' | sort | grep -v '^shell_session_');
    mapfile sysfuncnames < <(echo "${FUNCNAMES[@]}" | xargs -n1  echo | grep '^_');
    mapfile userfuncnames < <(echo "${FUNCNAMES[@]}" | xargs -n1  echo | grep -v '^_');

    hr -d'-'
    {
        echo -e "\\n\\033[46;37;1m FUNCTIONS: \\033[00;00;0m";
        echo -e "\\n[36m sys:[00m\\n${sysfuncnames[*]}";
        echo -e "\\n[36m user:[00m";
        echo "${userfuncnames[@]}" | xargs -n1 echo | nl \
            | trim \
            | tr '\t' ' ' | tr -s ' ';
        echo;
    } \
        | sed -E -e 's/^/   /';
    hr -d'-';
    return;
}

#shellcheck disable=2120
function trim () {
    local INPUT;
    if [[ -p /dev/stdin ]];
    then
        INPUT="$(cat /dev/stdin)";
        [[ -z "${INPUT}" ]] && return 11;
    elif (($#>0));
    then
        INPUT="${*:?ERROR, no input detected}";
    fi

    ## INPUT verified
    local OUTPUT;
    OUTPUT="$(echo "${INPUT}" \
        | sed -E -e 's/^[[:blank:]]*//' \
            -e 's/[[:blank:]]*$//')" \
     || return 12;
    [[ -z "${OUTPUT:-}" ]] && return 13;
    echo -e "${OUTPUT}";
    return;
}

if command -v shellcheck &> /dev/null;
then
    function sch () { 
        local TARGET;
        TARGET="${1:?no target file given}";
        local -a LVL;
        LVL=('error' 'warning' 'info' 'style');
        for l in "${LVL[@]}";
        do
            lvl_output="$(shellcheck -xa "${TARGET}" -f gcc -S "${l}" | grep -v '^[[:blank:]]*$')";
            local -i output_count;
            #shellcheck disable=2126
            output_count=$(echo "${lvl_output}" | grep -v '^[[:blank:]]*$' | wc -l | tr -dc '0-9');
            printf '\t%8s: %s\n' "${l}" "${output_count}";
            if (( output_count == 0 )); then
                printf '<NONE>\n';
            else
                echo "${lvl_output}";
            fi;
        done;
        return;
        echo;
        __build_hdr_str "ERROR";
        shellcheck -xa "${TARGET}" -f gcc -S error;
        __build_hdr_str "WARNING";
        shellcheck -xa "${TARGET}" -f gcc -S warning;
        __build_hdr_str "INFO";
        shellcheck -xa "${TARGET}" -f gcc -S info;
        __build_hdr_str "STYLE";
        shellcheck -xa "${TARGET}" -f gcc -S style;
        echo;
        return;
    }
fi
