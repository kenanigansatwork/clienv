#!/usr/bin/env bash
# ~/.bashrc

# shellcheck shell=bash

{ # helper variables and functions

    [[ ! -e ~/.hushlogin ]] && builtin echo -n > ~/.hushlogin

    export CLR_SUCCESS_HEADER=$'\033[42;37;1m'
    CLR_MSG_HEADER=$'\033[40;33;1m'
    CLR_MSG_TXT=$'\033[35;1m'
    export CLR_ERR_HEADER=$'\033[41;37;1m'
    export CLR_ERR_TXT=$'\033[31;1m'
    export CLR_RST=$'\033[00m'

    if [[ -z "${DEBUG_LEVEL:-}" ]]; then
        declare -ix DEBUG_LEVEL
        DEBUG_LEVEL=-2
    fi
    (( DEBUG_LEVEL > -2 )) && printf '[DEBUG_LEVEL: %d]\n' "${DEBUG_LEVEL}"

#    function _err () {
#        local -i OPTIND; OPTIND=1
#        local headerStr; headerStr='ERROR';
#        while getopts :h: OPT; do
#            case "${OPT}" in
#                h) headerStr="${OPTARG}";;
#                :) _err "flag requires an argument -- \`${OPTARG}'";;
#                *) _err "invalid option flag -- \`${OPTARG}'";;
#            esac
#        done
#        shift $((OPTIND-1));
#
#        local msg header;
#        msg="${*:-"an unspecified error occurred"}";
#        header=" ${headerStr} ";
#        printf ' %s%s%s %s%s%s\n' \
#            "${CLR_ERR_HEADER}" \
#            "${header}" \
#            "${CLR_RST}" \
#            "${CLR_ERR_TXT}" \
#            "${msg}" \
#            "${CLR_RST}" >&2;
#        return 0
#    }

    function _msg () {
        local -i leadingLine trailingLine OPTIND;
        OPTIND=1
        leadingLine=0;  # will prepend line if == 1
        trailingLine=0;  # will append line if == 1

        # handle options
        while getopts :l: OPT;
        do
            case "${OPT}" in
                l)
                    # lines
                    case "${OPTARG}" in
                        p|pre|prepend) leadingLine=1;;
                        a|append) trailingLine=1;;
                        b|both) leadingLine=1; trailingLine=1;;
                        *) return 222;;
                    esac
                ;;
                :)
                    echo FUCK;
                    case "${OPTARG}" in
                        l)
                            # `l' flag without arguments: assume both is specified
                            leadingLine=1; trailingLine=1;
                        ;;
                        *) return 223;;
                    esac
                ;;
                *)
                ;;
            esac
        done
        shift $((OPTIND-1));

        local msg header headerStr;
        headerStr="[clienv]"
        msg="${*:?}";
        header="${headerStr}";
        local OUTPUT;
        OUTPUT='';
        OUTPUT+="${CLR_MSG_HEADER} ${header} ${CLR_RST}";
        OUTPUT+="${CLR_MSG_TXT} ${msg} ${CLR_RST}";

        if (( leadingLine ==1 ))
        then OUTPUT='\n'"${OUTPUT}";
        fi

        if (( trailingLine ==1 ))
        then OUTPUT+='\n'
        fi

        #printf '  %s %s %s: %s%s%s\n' \
            #"${CLR_MSG_HEADER}" "${header}" "${CLR_RST}" \
            #"${CLR_MSG_TXT}" "${msg}" "${CLR_RST}" >&2;

        echo -e "${OUTPUT:?"ERR"}"
        return 0
    }

    function _success () {
        local msg header;
        msg="${*:?}";
        header="SUCCESS";
        printf '  %s[ %s ]%s: %s\n' "${CLR_SUCCESS_HEADER}" "${header}" "${CLR_RST}" "${msg}" >&2;
        return 0
    }
    function _isMac () { if [[ "$(uname)" == 'Darwin' ]]; then return 0; fi; return 1; }
    function _hasCommand () { local TARGET; TARGET="${1:?}"; if command -v "${TARGET}" &> /dev/null; then return 0; fi; return 1; }

    if _isMac && _hasCommand system_profiler; then
        function _sysinfo () 
        { 
            local -i DEBUG; DEBUG=0;
            if [[ "${1:-}" =~ (-|--)?(D|DEBUG|debug)$ ]];
            then
                DEBUG=1; shift 1;
            fi;
            tmpfile="$(mktemp)";
            builtin trap '(( DEBUG == 1 )) && /usr/bin/printf "removing temp file (${tmpfile})... "; if /bin/rm "${tmpfile}"; then (( DEBUG == 1 )) && /bin/echo SUCCESS; else (( DEBUG == 1 )) && /bin/echo FAILED; fi;' RETURN;
            (( DEBUG == 1 )) && /usr/bin/printf '\n  > [DEBUG]: TEMPFILE -- %s\n\n' "${tmpfile}";
            /usr/sbin/system_profiler -detailLevel mini -xml SPSoftwareDataType > "${tmpfile}";
            /usr/bin/plutil -p "${tmpfile}" | /usr/bin/sed -n '/^[[:blank:]]*"_name"/,/^[[:blank:]]*"uptime"/p' | /usr/bin/tr -d '"' | /usr/bin/sed 's/^[[:blank:]][[:blank:]]*_*\([^[:blank:]]*\)  *=>  *\(.*$\)/\1|\2/' | /usr/bin/awk -F"|" 'BEGIN{printf "\nSYSTEM INFO:\n"}{printf ("- %*s %s\n",-15,$1":",$2)}';
            builtin echo;
            return
        }
    fi
}

{ # LOCATION VARIABLES
    if [[ -n "${_location_variables[*]}" ]]; then
        # unset all location variables
        for key in "${!_location_variables[@]}"; do
            unset "${key}"
        done
    fi
    unset _location_variables
    
    declare -A _location_variables; _location_variables=()
    declare -A _location_variable_errors; _location_variable_errors=()

    function validateAndSetLocationVariables() {
        local NAME DIR;
        NAME="${1:?}" DIR="${2:?}"
        if [[ ! -d "${DIR}" ]]; then
            _location_variable_errors["${NAME}"]="${DIR}"
            (( DEBUG_LEVEL >= -1 )) && _err "unable to set variable. directory not found -- ${DIR}"
            return 1
        fi
        if [[ -n "${!NAME:-}" ]]; then
            _location_variable_errors["${NAME}"]="${DIR}"
            (( DEBUG_LEVEL >= 0 )) && _err "name has already been set previously -- ${!NAME}"
            return 2
        fi
        eval "${NAME}=\"${DIR}\""
        if [[ -n "${!NAME}" && "${!NAME}" == "${DIR}" ]]; then
            _location_variables["${NAME}"]="${DIR}"
            (( DEBUG_LEVEL == 1 )) && _success "${NAME} => ${!NAME}"
        fi
    }

    { # set location variables here
        (( DEBUG_LEVEL >= 0 )) && printf '\n  [%s] => %s\n\n' 'clienv' 'setting location variables';

        if _isMac; then
            validateAndSetLocationVariables "clienv" ~/Developer/repos/clienv
            validateAndSetLocationVariables "clienvbash" ~/Developer/repos/clienv/src/bash
            validateAndSetLocationVariables "dev" ~/Developer
            validateAndSetLocationVariables "scriptsold" ~/Developer/scripts
            validateAndSetLocationVariables "scripts" "${clienv:?}/src/scripts"
            validateAndSetLocationVariables "scriptssandbox" "${clienv:?}/src/scripts/_sandbox"
            validateAndSetLocationVariables "scriptsbash" "${clienv:?}/src/scripts/bash"
            validateAndSetLocationVariables "bashscripts" "${clienv:?}/src/scripts/bash"
            validateAndSetLocationVariables "shellscripts" ~/Developer/scripts/shell-scripts
            validateAndSetLocationVariables "repos" ~/Developer/repos
            validateAndSetLocationVariables "desk" ~/Desktop
            validateAndSetLocationVariables "docs" ~/Documentssssss
            validateAndSetLocationVariables "dl" ~/Downloads
            validateAndSetLocationVariables "sites" ~/Sites
            validateAndSetLocationVariables "favs" ~/Library/Favorites/
            validateAndSetLocationVariables "proj" ~/Projects
            validateAndSetLocationVariables "var" /private/var
            validateAndSetLocationVariables "etc" /private/etc
            if [[ -d /usr/local ]];
            then
                validateAndSetLocationVariables "uvar" /usr/local/var
                validateAndSetLocationVariables "uetc" /usr/local/etc
                validateAndSetLocationVariables "uetc2" /usr/local/etcc
                validateAndSetLocationVariables "uetc" /usr/local/
            fi
        elif [[ "$(uname)" == 'Linux' ]]
        then
            validateAndSetLocationVariables "repos" ~/repos
            validateAndSetLocationVariables "clienv" ~/repos/clienv
            validateAndSetLocationVariables "www" ~/public_html
        fi
    }

shopt -s cdable_vars

    if (( ${#_location_variable_errors[@]} > 0 )); then
        (( DEBUG_LEVEL >= 0 )) && _err "location variable assignment errors occurred (${#_location_variable_errors[@]})"
    fi
    
    # clean up
    unset -f validateAndSetLocationVariables
    unset _location_variable_errors
} # END LOCATION VARIABLES

{ # set bash-git-prompt-config
    declare bashgitprompt_file;
    bashgitprompt_file="${clienv:?}/src/bash/bashrc.d/bash-git-prompt-config.sh"
    if [[ -r "${bashgitprompt_file}" ]]
    then
        #shellcheck disable=1090
        . "${bashgitprompt_file}"
    fi
}

{ # ENVIRONMENTAL VARIABLES
    _isMac && export GLOBIGNORE=.DS_Store:.CFUserTextEncoding:.localized:.hushlogin:.Trash:.viminfo:.zsh_history:.bash_history:.lesshst:.less_history:.node_repl_history:.gitconfig:.gitignore_global:.wget-hsts:.ssh:.bash_sessions:.mysql_history:.hushlogin
    if [[ "$(uname)" == 'Linux' ]]
    then
        export PAGER=cat;
    fi

    export CDPATH=.:~
    export LSCOLORS=$'Exfxcxdxbxegedabagacad';      # default =. 'exfxcxdxbxegedabagacad'
    export HISTFILE=~/.bash_history
    export HISTFILESIZE=100000
    export HISTSIZE=100000
    export HISTCONTROL='ignoreboth'
    export MYSQL_HISTFILE=~/.mysql_history
    export LESSHISTFILE=~/.less_history
    export LESSHISTSIZE=10000
    export EDITOR='vim'

    if [[ -d /usr/local/sbin ]] \
        && ! builtin echo "$PATH" | grep -q "/usr/local/sbin"
    then
        export PATH="${PATH:+"${PATH}:"}/usr/local/sbin"
    fi

    if [[ -d "${HOME}/bin" ]] \
        && ! builtin echo "${PATH}" |  grep -q "${HOME}/bin"
    then
        export PATH="${HOME}/bin${PATH:+":${PATH}"}"
    fi

    # DE-DUPE $PATH
    #shellcheck disable=2155
    export PATH="$(echo -e "${PATH//:/\\n}" | uniq | tr '\n' ':' | sed 's/:$//')"

    { # SET PROMPT VARIABLE (PS1)

        if hostname | grep -q 'a2plcpnl0845';
        then
            if ((EUID == 0)); then
                # set root prompt
                export PS1=$'\[\e[41;37;1m\]\u@kenanigans:\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
            else
                #export PS1=$'[\[\e[46;37;1m\] \u@kenanigans \[\e[00;00;0m\]:\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
                export PS1=$'[\W]\$ ';
            fi
        else
            if ((EUID == 0)); then
                # set root prompt
                export PS1=$'\[\e[41;37;1m[\u]\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
            else
                #export PS1=$'[\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
                export PS1=$'[\W]\$ ';
            fi
        fi
    }

    { # SET PROMPT_COMMAND
    
        unset -f ps1_command

        function ps1_command() {
            local -ir xit=$?;

            if (( xit != 0 )); then
                builtin echo
                _err \
                    -h"ERROR (${xit}) [00;00;0m" \
                    "[31m[last_command]:[00m [40;33m $(history 1 | sed 's:^[[:blank:]]*[0-9][0-9]*[[:blank:]]*\(.*$\):\1:') [00;00;0m";
                builtin echo
            fi
            return ${xit}
        }

        if ! builtin echo "${PROMPT_COMMAND}" | grep -q 'ps1_command'; then
            PROMPT_COMMAND='ps1_command'"${PROMPT_COMMAND:+";${PROMPT_COMMAND}"}"
        fi

    }

}

{ # USER ALIASES

    #shellcheck disable=2015
    _isMac && alias ls='ls -hGT' \
        || alias ls='ls --color=auto'

    alias dff='declare -f f 2> /dev/null'
    alias la='ls -A'
    alias ll='ls -og'
    alias lla='ls -ogA'
    alias l1='ls -1'
    alias lm='ls -m'
    alias l.='ls -d .[^$.]* 2> /dev/null'
    alias ll.='ls -ogd .[^$.]* 2> /dev/null'
    alias l1.='ls -1d .[^$.]* 2> /dev/null'
    alias lm.='ls -md .[^$.]* 2> /dev/null'
    alias lll.='ls -ogdL .[^$.]* 2> /dev/null'

    #alias c='clear'
    alias x='exit'
    alias sbash='[ -r ~/.bash_profile ] && . ~/.bash_profile'

    alias shutdown='sudo command shutdown -h now'
    alias shutdownh='sudo command shutdown -h now'
    alias shutdownr='sudo command shutdown -r now'

    if command -v git-cal &> /dev/null
    then
        gitcal () 
        { 
            /usr/bin/printf '\n%s\n%s\n\n' \
                "$(/usr/bin/git cal | /usr/bin/sed -E '/(Total commits)/,$d')" \
                "$(hr)"

            return
        }
    fi


    if _isMac;
    then
        alias grep='/usr/bin/grep --color=auto'
        alias egrep='/usr/bin/egrep --color=auto'
        alias fgrep='/usr/bin/fgrep --color=auto'

        alias appstore='open -a "App Store"';
    elif [[ "$(uname)" == 'Linux' ]]
    then
        alias grep='/bin/grep --color=auto'
        alias egrep='/bin/egrep --color=auto'
        alias fgrep='/bin/fgrep --color=auto'
    fi


    #alias trunc='cut -c1-${COLUMNS:-$(tput cols)}';
    alias mkdir='mkdir -p'

    if [[ -x "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport" ]]
    then
        alias airport='/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport'
    fi

    if [[ -x /Applications/GeekTool.app ]] && _isMac
    then
        alias geektool='open -a "GeekTool"'
    fi

}   # END USER ALIASES


f1 () {
    local OLDIFS; OLDIFS=$"${IFS}"
    IFS=$'\n'
    trap 'IFS=$"${OLDIFS}"; [[ "${OLDIFS}" != "${IFS}" ]] && _err "I broke the IFS variable"; return;' return HUP QUIT INT

    local target; local -a args
    target="${1:?}"; shift 1
    args=( [0]='-mindepth' [1]=1 [2]='-maxdepth' [3]=1 )
    args+=( "$@" )
    CMD="command find ${target}"
    for ((c=0;c<${#args[@]};c++)); do
        CMD+=" $(printf '%q' "${args[${c}]}")"
    done
    eval "${CMD}"
    return
}

function hr () {
    local -i OPTIND rtstrlength; OPTIND=1; rtstrlength=4
    local -i col; col=${COLUMNS:-$(tput cols)}
    local hrstr delim headertext; hrstr=''; delim='_'; headertext='';
    (( ${#delim} > 1 )) && delim="${delim:0:1}"
    while getopts :d:h:PD OPT
    do
        case "${OPT}" in
            d) delim="${OPTARG:0:1}"
            ;;
            D)
                # include date
                headertext="$(date +"%a %H:%M")"
            ;;
            P)
                # include $PWD
                headertext="${PWD}"
            ;;
            h) headertext="${OPTARG}"
            ;;
            :) _err "flag requires an argument -- ${OPTARG}"
            ;;
            *) _err "invalid option flag -- ${OPTARG}"
            ;;
        esac
    done; shift $((OPTIND-1))
    local text; text=''
    if [[ -z "${headertext:-}" ]]; then
        if (( $# > 0 )) ; then
            text="${*}";
        fi
    else
        text="${headertext}"
    fi
    (( ${#text} > col )) && { _err; return 2; }
    for (( c = 0; c < $(( col - ${#text} - $((rtstrlength+2)) )); c++ )); do
        hrstr="${hrstr}${delim}"
    done
    #if [[ -n "${text:-}" ]]; then hrstr+="[${text}]"
    if [[ -n "${text:-}" ]]; then hrstr+=" ${text} "
    else hrstr+="${delim}${delim}"
    fi
    for (( a = 0; a < rtstrlength; a++ )); do
        hrstr+="${delim}"
    done
    (( ${#hrstr} != col )) && { _err; return 1; }
    printf '%s\n' "${hrstr}"
    return
}

if declare -f hr &> /dev/null
then
    alias rtstr='hr -d" " -h';
    #alias rtdir='rtstr "$(echo "${PWD}" | sed "s:^/:root->:" | sed "s:root->${HOME#*/}/:home->:" | tr "/" "-")"';
    alias rtdir='rtstr "$(echo "${PWD}" | sed "s:^/:root->:" | sed "s:root->${HOME#*/}/:home->:" | tr "/" "-")"';
    alias rttime='rtstr "$(date +"%a %H:%M.%S")"';
    alias rtt='rtdir;rttime;';
    alias crtt='command clear && rtdir;rttime';
    #alias crttt='rtstr "$(echo "${PWD}" | sed "s:^/:root->:" | sed "s:root->${HOME#*/}/:🏡 ➡:" | tr "/" "-") | $(date +"%a %H:%M.%S")"'
    alias crttt='rtstr "$(echo -e "\\033[33;1m$(echo "${PWD}" | sed "s:^/:root->:" | sed "s:root->${HOME#*/}/:home->:" | tr "/" "-")\\033[00m \\033[1m|\\033[00m \\033[35;1m$(date +"%a %H:%M.%S")"\\033[00m)"'
fi

function funcs () {

    builtin declare -F | /usr/bin/cut -c12- | /usr/bin/sort | /usr/bin/column;
    return;

    #shellcheck disable=2207
    declare -F | sed -E 's/^declare -[a-z0-1A-Z]+ //' | sort | grep -v '^shell_session_'
    mapfile FUNCNAMES < <(declare -F | sed -E 's/^declare -[a-z0-1A-Z]+ //' | sort | grep -v '^shell_session_');
    mapfile sysfuncnames < <(builtin echo "${FUNCNAMES[@]}" | xargs -n1  builtin echo | grep '^_');
    mapfile userfuncnames < <(builtin echo "${FUNCNAMES[@]}" | xargs -n1  builtin echo | grep -v '^_');

    hr -d'-'
    {
        builtin echo -e "\\n\\033[46;37;1m FUNCTIONS: \\033[00;00;0m";
        builtin echo -e "\\n[36m sys:[00m\\n${sysfuncnames[*]}";
        builtin echo -e "\\n[36m user:[00m";
        builtin echo "${userfuncnames[@]}" | xargs -n1 echo | nl \
            | trim \
            | tr '\t' ' ' | tr -s ' ';
        builtin echo;
    } \
        | sed -E -e 's/^/   /';
    hr -d'-';
    return;
}

aliases ()
{
    _list_defs () {
        printf '\033[45;37;1m ALIAS DEFS: \033[00m\n%s\n%s\n' "$(alias | cut -d' ' -f2- | awk -F"=" '{printf ("%15s   => %s\n",$1,$2)}')" "$(hr -d '-')";
        return;
    }

    _list_names () {
        printf '\033[45;37;1m ALIAS NAMES: \033[00m\n%s\n' "$(alias|cut -d' ' -f2- | sed 's/=.*$//' | sort | column)";
        return;
    }

    _formatted_output () {
        hr;
        _list_defs;
        _list_names;
        hr -d '-';
        echo;
        return;
    }

    local -i OPTIND; OPTIND=1;
    while getopts :nda OPT;
    do
        case "${OPT}" in
            n) # list names
                hr;
                _list_names;
                hr;echo;
                return;
            ;;
            d) # list defs
                hr;
                _list_defs;
                echo;
                return;
            ;;
            a) # list both
                _formatted_output;
                return;
            ;;
            *) _err "invalid flag -- ${OPTARG}"
                return 11;
            ;;
        esac;
    done;
    shift $((OPTIND-1));

    _formatted_output;
    return;
}

#shellcheck disable=2120
#function trim () {
#    local INPUT;
#    if [[ -p /dev/stdin ]];
#    then
#        INPUT="$(cat /dev/stdin)";
#        [[ -z "${INPUT}" ]] && return 11;
#    elif (($#>0));
#    then
#        INPUT="${*:?ERROR, no input detected}";
#    fi
#
#    ## INPUT verified
#    local OUTPUT;
#    OUTPUT="$(builtin echo "${INPUT}" \
#        | sed -E -e 's/^[[:blank:]]*//' \
#            -e 's/[[:blank:]]*$//')" \
#     || return 12;
#    [[ -z "${OUTPUT:-}" ]] && return 13;
#    builtin echo -e "${OUTPUT}";
#    return;
#}

#if declare -f trim &> /dev/null;
#then
#    alias lines='/usr/bin/wc -l | trim | tr -d "\n"'
#fi


if command -v shellcheck &> /dev/null;
then
    function sch () { 

        _list_level_output () {
            shellcheck -xa "${TARGET}" -f gcc -S "${l}" | grep -v '^[[:blank:]]*$'
            return
        }

        _check_file () {
            hr
            local TARGET; TARGET="${1:?no target file given}";
            #verify file exists and readable
            if [[ ! -e "${TARGET}" || ! -f "${TARGET}" || ! -r "${TARGET}" ]]; then
                _err "unable to find, access, or read specified target: ${TARGET}"
                return
            fi
            for l in "${LVL[@]}";
            do
                lvl_output="$(_list_level_output)";
                local -i output_count;
                #shellcheck disable=2126
                output_count=$(builtin echo "${lvl_output}" | grep -v '^[[:blank:]]*$' | wc -l | tr -dc '0-9');
                printf '\t%8s: %s\n' "${l}" "${output_count}";
                if ! (( output_count == 0 )); then
                    builtin echo "${lvl_output}";
                fi;
            done;
            return;
            builtin echo;
            __build_hdr_str "ERROR";
            shellcheck -xa "${TARGET}" -f gcc -S error;
            __build_hdr_str "WARNING";
            shellcheck -xa "${TARGET}" -f gcc -S warning;
            __build_hdr_str "INFO";
            shellcheck -xa "${TARGET}" -f gcc -S info;
            __build_hdr_str "STYLE";
            shellcheck -xa "${TARGET}" -f gcc -S style;
            builtin echo;
            return;
        }

        (( $# == 0 )) && _err "no input files passed" && return 11

        for filename in "$@"; do
            _check_file "${filename}"
        done
    }
fi

function paths () {
    _output_path () {
        echo "PATH: ${PATH}"
        return
    }

    _raw_list () {
        builtin echo -e "${PATH//:/\\n}"
        return
    }

    _numbered_list () {
        _raw_list \
            | nl
        return
    }

    _list_verbose() {
        hr
        _output_path
        printf '\n  %s:\n\n%s\n\n' \
            "PATHS" \
            "$(_numbered_list)"
        hr
        return
    }

    local -i OPTIND; OPTIND=1
    while getopts :rnbv OPT;
    do
        case "${OPT}" in
            v) #verbose
                _list_verbose
                return
            ;;
            b) #basic
                _output_path
                return
            ;;
            r) #list raw
                _raw_list
                return
            ;;
            n) #list numbered
                _numbered_list
                return
            ;;
            :)
                _err "flag requires an argument -- ${OPTARG}"
                return 1
            ;;
            *)
                _err "invalid flag -- ${OPTARG}"
                return 1
            ;;
        esac
    done
    shift $((OPTIND=1))

    #_numbered_list
    _list_verbose
    return
}

function clienv () {

    # handle option flags
    local -i OPTIND VERBOSITY;
    OPTIND=1; VERBOSITY=0;
    # -b: specify to list bash init files

    while getopts :bnav OPT;
    do
        case "${OPT}" in
            a)
                # list all src files
                find "$clienv/src" -type f \
                    | sed 's/^.*\(clienv\)/\1/';
                return;
            ;;
            b)
                #shellcheck disable=2046,2086
                command grep '/usr/bin/env bash' $(find $clienv/src -type f) \
                    | sed 's/^\(.*\):.*$/\1/' | sort | uniq \
                    | sed 's/^.*\(clienv\)/\1/';
                return;
            ;;
            n)
                # list files not part of bash
                while IFS= read -r FILEPATH;
                do
                    if ! grep -q '/usr/bin/env bash' "${FILEPATH}";
                    then
                        echo "${FILEPATH}";
                    fi
                done < <(find "$clienv/src" -type f) \
                    | sed 's/^.*\(clienv\)/\1/';
                return;
            ;;
            v)
                ((VERBOSITY++));
            ;;
            :)
                _err "option flag requires an argument -- \`${OPTARG}'";
            ;;
            *)
                _err "invalid flag -- ${OPTARG}";
            ;;
        esac
    done
    shift $((OPTIND-1));

    # validate location var
    [[ -z "${clienv:-}" ]] && return 11;
    [[ -d "${clienv}" ]] || return 12;

    if ! cd "${clienv}";
    then # ensure move into directory
        _err "unable to move to \${clienv} directory -- ${clienv}";
        return 13;
    fi;

    if (( VERBOSITY > 0 ));
    then
        { # output report
            hr -d'-';
            printf '  => PWD: %s\n' "$PWD"
            if (( VERBOSITY > 1 ));
            then
                _msg "STATUS:";
                git status;
                hr;
            fi
            if (( VERBOSITY == 1 ));
            then
                hr -d'-';
                _msg "BRANCHES:";
                git branch -a;
                hr;
                _msg "REMOTES:";
                git remote -v;
                    hr;
            fi
        }
    fi

    return;
}

if _isMac; then
    function kenanigans () {
        ssh kenanigans
        return
    }
fi


if ! alias trunc &> /dev/null; then
    function trunc () {
        local INPUT;
        INPUT='';
        if [[ -p /dev/stdin ]];
        then
            INPUT="$(cat /dev/stdin)";
            [[ -z "${INPUT}" ]] && return 11;
        elif (($#>0));
        then
            INPUT="${*:?ERROR, no input detected}";
        fi

        ## INPUT verified
        local OUTPUT;
        OUTPUT="$(builtin echo "${INPUT}" | cut -c1-${COLUMNS:-$(tput cols)})"
        [[ -z "${OUTPUT:-}" ]] && return 13;
        builtin echo -e "${OUTPUT}";
        return;
    }
fi

if _isMac; then
    # make trash function
    trash () {
        local TRASH_DIR
        TRASH_DIR=~/.Trash
        [[ ! -d "${TRASH_DIR}" ]] && return 202;

        _list_trash_directory_status () {
            local SIZE
            #shellcheck disable=2116
            SIZE="$(echo \
        "$(echo "scale=2; $(( $(du -s ~/Movies | tr -dc '0-9') * 512 ))/1000/1000" | bc) MB")";
            if [[ "${SIZE:0:1}" =~ ^\.$ ]]; then SIZE="0${SIZE}"; fi
            echo "TRASH SIZE: ${SIZE}"
            return
        }

        local -i OPTIND; OPTIND=1
        while getopts :s OPT; do
            case "${OPT}" in
                s)
                    _list_trash_directory_status
                    echo facek
                    return
                ;;
                *)
                    _err "invalid flag -- ${OPTARG}"
                ;;
            esac
        done

        _list_trash_directory_status

        return
    }

    beep () {
        local -i count; count=${1:-1}
        osascript -e "beep ${count}"
        return
    }

    
    if declare -f hr &> /dev/null
    then
        clearl ()
        {
            /usr/bin/clear;
            /usr/bin/printf '\n  PWD: %s\n  TIME: %s\n\n' "${PWD}" "$(date +"%a %H:%M.%S")";
            /bin/ls -hGTA;
            hr;
            echo;
            return
        }
        declare -f clearl &> /dev/null \
            && alias cl='clearl';
    fi

fi
