#!/usr/bin/env bash
# ~/.bashrc

# shellcheck shell=bash

{ # helper variables and functions

    [[ ! -e ~/.hushlogin ]] && builtin echo -n > ~/.hushlogin

    export CLR_SUCCESS_HEADER=$'\033[42;37;1m'
    CLR_MSG_HEADER=$'\033[40;33;1m'
    CLR_MSG_TXT=$'\033[35;1m'
    export CLR_ERR_HEADER=$'\033[41;37;1m'
    export CLR_ERR_TXT=$'\033[31;1m'
    export CLR_RST=$'\033[00m'

    if [[ -z "${DEBUG_LEVEL:-}" ]]; then
        declare -ix DEBUG_LEVEL
        DEBUG_LEVEL=-2
    fi
    (( DEBUG_LEVEL > -2 )) && /usr/bin/printf '[DEBUG_LEVEL: %d]\n' "${DEBUG_LEVEL}"

    function _msg ()
    {
        # function _err () {
        #     local -i OPTIND; OPTIND=1
        #     local headerStr; headerStr='ERROR';
        #     while getopts :h: OPT; do
        #         case "${OPT}" in
        #             h) headerStr="${OPTARG}";;
        #             :) _err "flag requires an argument -- \`${OPTARG}'";;
        #             *) _err "invalid option flag -- \`${OPTARG}'";;
        #         esac
        #     done
        #     shift $((OPTIND-1));
        #     local msg header;
        #     msg="${*:-"an unspecified error occurred"}";
        #     header=" ${headerStr} ";
        #     /usr/bin/printf ' %s%s%s %s%s%s\n' \
        #         "${CLR_ERR_HEADER}" \
        #         "${header}" \
        #         "${CLR_RST}" \
        #         "${CLR_ERR_TXT}" \
        #         "${msg}" \
        #         "${CLR_RST}" >&2;
        #     return 0
        # }

        local -i leadingLine trailingLine OPTIND indentFlag;
        OPTIND=1
        leadingLine=0;  # will prepend line if == 1
        trailingLine=0;  # will append line if == 1
        indentFlag=0;  # will indent if == 1

        # handle options
        while getopts :l:i OPT; do
            case "${OPT}" in
                i) indentFlag=1;;
                l)
                    # lines
                    case "${OPTARG}" in
                        p|pre|prepend) leadingLine=1;;
                        a|append) trailingLine=1;;
                        b|both) leadingLine=1; trailingLine=1;;
                        *) return 222;;
                    esac
                ;;
                :)
                    case "${OPTARG}" in
                        l)
                            # `l' flag without arguments: assume both is specified
                            leadingLine=1; trailingLine=1;
                        ;;
                        *) return 223;;
                    esac
                ;;
                *)
                ;;
            esac
        done
        shift $((OPTIND-1));

        local msg header headerStr;
        headerStr="[clienv]"
        msg="${*:?}";
        header="${headerStr}";
        local OUTPUT;
        OUTPUT='';
        OUTPUT+="${CLR_MSG_HEADER} ${header} ${CLR_RST}";
        OUTPUT+="${CLR_MSG_TXT} ${msg} ${CLR_RST}";

        if (( leadingLine ==1 ))
        then OUTPUT='\n'"${OUTPUT}";
        fi

        if (( trailingLine ==1 ))
        then OUTPUT+='\n'
        fi

        if (( indentFlag ==1 ))
        then
            OUTPUT="$(echo -e "${OUTPUT}" | sed -E 's|^|	|')"
        fi

        #printf '  %s %s %s: %s%s%s\n' \
            #"${CLR_MSG_HEADER}" "${header}" "${CLR_RST}" \
            #"${CLR_MSG_TXT}" "${msg}" "${CLR_RST}" >&2;

        echo -e "${OUTPUT:?"ERR"}"
        return 0
    }

    function _success ()
    {
        local msg header;
        msg="${*:?}";
        header="SUCCESS";
        /usr/bin/printf '  %s[ %s ]%s: %s\n' "${CLR_SUCCESS_HEADER}" "${header}" "${CLR_RST}" "${msg}" >&2;
        return 0
    }
    function _isMac () { if [[ "$(uname)" == 'Darwin' ]]; then return 0; fi; return 1; }
    function _hasCommand () { local TARGET; TARGET="${1:?}"; if command -v "${TARGET}" &> /dev/null; then return 0; fi; return 1; }

    if _isMac && _hasCommand system_profiler; then
        function _sysinfo () 
        { 
            local -i DEBUG; DEBUG=0;
            if [[ "${1:-}" =~ (-|--)?(D|DEBUG|debug)$ ]];
            then
                DEBUG=1; shift 1;
            fi;
            tmpfile="$(mktemp)";
            builtin trap '(( DEBUG == 1 )) && /usr/bin/printf "removing temp file (${tmpfile})... "; if /bin/rm "${tmpfile}"; then (( DEBUG == 1 )) && /bin/echo SUCCESS; else (( DEBUG == 1 )) && /bin/echo FAILED; fi;' RETURN;
            (( DEBUG == 1 )) && /usr/bin/printf '\n  > [DEBUG]: TEMPFILE -- %s\n\n' "${tmpfile}";
            /usr/sbin/system_profiler -detailLevel mini -xml SPSoftwareDataType > "${tmpfile}";
            /usr/bin/plutil -p "${tmpfile}" \
                | /usr/bin/sed -n '/^[[:blank:]]*"_name"/,/^[[:blank:]]*"uptime"/p' \
                | /usr/bin/tr -d '"' \
                | /usr/bin/sed 's/^[[:blank:]][[:blank:]]*_*\([^[:blank:]]*\)  *=>  *\(.*$\)/\1|\2/' \
                | /usr/bin/awk -F"|" 'BEGIN{printf "\nSYSTEM INFO:\n"}{printf ("- %*s %s\n",-15,$1":",$2)}';
            builtin echo;
            return
        }
    fi
}

{ # LOCATION VARIABLES
    if [[ -n "${_location_variables[*]}" ]]; then
        # unset all location variables
        for key in "${!_location_variables[@]}"; do
            unset "${key}"
        done
    fi
    unset _location_variables
    
    declare -A _location_variables; _location_variables=()
    declare -A _location_variable_errors; _location_variable_errors=()

    function validateAndSetLocationVariables() {
        local NAME DIR;
        NAME="${1:?}" DIR="${2:?}"
        if [[ ! -d "${DIR}" ]]; then
            _location_variable_errors["${NAME}"]="${DIR}"
            (( DEBUG_LEVEL >= -1 )) && _err "unable to set variable. directory not found -- ${DIR}"
            return 1
        fi
        if [[ -n "${!NAME:-}" ]]; then
            _location_variable_errors["${NAME}"]="${DIR}"
            (( DEBUG_LEVEL >= 0 )) && _err "name has already been set previously -- ${!NAME}"
            return 2
        fi

        eval "${NAME}=\"${DIR}\""
        if [[ -n "${!NAME}" && "${!NAME}" == "${DIR}" ]]; then
            _location_variables["${NAME}"]="${DIR}"
            (( DEBUG_LEVEL == 1 )) && _success "${NAME} => ${!NAME}"
        fi
    }

    { # set location variables here
        (( DEBUG_LEVEL >= 0 )) && /usr/bin/printf '\n  [%s] => %s\n\n' 'clienv' 'setting location variables';

        if _isMac; then
            validateAndSetLocationVariables "clienv" ~/Developer/repos/clienv
            validateAndSetLocationVariables "clienvbash" ~/Developer/repos/clienv/src/bash
            validateAndSetLocationVariables "dev" ~/Developer
            validateAndSetLocationVariables "blockparty" ~/Developer/repos/blockparty

            if [[ -x "${HOME}/Library/Mobile Documents/com~apple~CloudDocs" ]]; then
                validateAndSetLocationVariables "icloud" "${HOME}/Library/Mobile Documents/com~apple~CloudDocs"
                validateAndSetLocationVariables "pythonista" "${HOME}/Library/Mobile Documents/iCloud~com~omz-software~Pythonista3"
                validateAndSetLocationVariables "readdledocs" "${HOME}/Library/Mobile Documents/3L68KQB4HG~com~readdle~CommonDocuments/Documents"
            fi

            if [[ -x "${clienv:?}/src/bash/bashrc.d/functions"  ]]; then
                validateAndSetLocationVariables "funcs" "${clienv:?}/src/bash/bashrc.d/function"
            fi

            validateAndSetLocationVariables "scriptsold" ~/Developer/scripts
            validateAndSetLocationVariables "scripts" "${clienv:?}/src/scripts"
            validateAndSetLocationVariables "sandbox" "${clienv:?}/src/scripts/_sandbox"
            validateAndSetLocationVariables "scriptsbash" "${clienv:?}/src/scripts/bash"
            validateAndSetLocationVariables "bashscripts" "${clienv:?}/src/scripts/bash"
            validateAndSetLocationVariables "shellscripts" "${HOME}/Developer/scripts/shell-scripts"
            validateAndSetLocationVariables "repos" ~/Developer/repos
            validateAndSetLocationVariables "desk" ~/Desktop
            validateAndSetLocationVariables "docs" ~/Documents
            validateAndSetLocationVariables "dl" ~/Downloads
            validateAndSetLocationVariables "sites" ~/Sites
            validateAndSetLocationVariables "favs" ~/Library/Favorites
            validateAndSetLocationVariables "proj" ~/Projects
            validateAndSetLocationVariables "var" /private/var
            validateAndSetLocationVariables "etc" /private/etc
            if [[ -d /usr/local ]]; then
                validateAndSetLocationVariables "uvar" /usr/local/var
                validateAndSetLocationVariables "uetc" /usr/local/etc
                validateAndSetLocationVariables "uetc2" /usr/local/etcc
                validateAndSetLocationVariables "uetc" /usr/local/
            fi
        elif [[ "$(uname)" == 'Linux' ]]; then
            validateAndSetLocationVariables "repos" ~/repos
            validateAndSetLocationVariables "clienv" ~/repos/clienv
            validateAndSetLocationVariables "www" ~/public_html
        fi
    }


    if [[ -n "${icloud:-}" ]]; then
        function icloud()
        {
            local icloud_app_folder_dir
            icloud_app_folder_dir="$(dirname "${icloud}")"

            if ! cd "${icloud}"; then
                _err "failed to move to iCloud directory"
                return 11
            else
                echo "NOW IN iCloud directory: ${PWD}"
            fi

            if (( $# > 0 )); then
                for ARG in "$@"; do
                    hr -h "$ARG"
                    local CMD
                    CMD="{ echo \"${icloud_app_folder_dir}/${ARG}\"*; } 2> /dev/null \
                        && echo FOUND \
                        || _err \"DIR NOT FOUND: ${ARG}\""
                    eval "${CMD}"
                done
                hr
            fi
            return 0
        }
    fi

    shopt -s cdable_vars globstar failglob

    if (( ${#_location_variable_errors[@]} > 0 )); then
        (( DEBUG_LEVEL >= 0 )) && _err "location variable assignment errors occurred (${#_location_variable_errors[@]})"
    fi
    
    # clean up
    unset -f validateAndSetLocationVariables
    unset _location_variable_errors
} # END LOCATION VARIABLES

{ # set bash-git-prompt-config
    declare bashgitprompt_file;
    bashgitprompt_file="${clienv:?}/src/bash/bashrc.d/bash-git-prompt-config.sh"
    if [[ -r "${bashgitprompt_file}" ]]
    then
        #shellcheck disable=1090
        . "${bashgitprompt_file}"
    fi
}

{ # ENVIRONMENTAL VARIABLES
    _isMac && export GLOBIGNORE=.DS_Store:.CFUserTextEncoding:.localized:.hushlogin:.Trash:.viminfo:.zsh_history:.bash_history:.lesshst:.less_history:.node_repl_history:.gitconfig:.gitignore_global:.wget-hsts:.ssh:.bash_sessions:.mysql_history:.hushlogin
    if [[ "$(uname)" == 'Linux' ]]
    then
        export PAGER=cat;
    fi

    export CDPATH=.:~
    export LSCOLORS=$'Exfxcxdxbxegedabagacad';      # default =. 'exfxcxdxbxegedabagacad'
    export HISTFILE=~/.bash_history
    export HISTFILESIZE=100000
    export HISTSIZE=100000
    export HISTCONTROL='ignoreboth'
    export MYSQL_HISTFILE=~/.mysql_history
    export LESSHISTFILE=~/.less_history
    export LESSHISTSIZE=10000
    export EDITOR='vim'

    if [[ -d /usr/local/sbin ]] && ! builtin echo "$PATH" | grep -q "/usr/local/sbin"
    then
        export PATH="${PATH:+"${PATH}:"}/usr/local/sbin"
    fi

    if [[ -d "${HOME}/bin" ]] \
        && ! builtin echo "${PATH}" |  grep -q "${HOME}/bin"
    then
        export PATH="${HOME}/bin${PATH:+":${PATH}"}"
    fi

    # DE-DUPE $PATH
    #shellcheck disable=2155
    export PATH="$(echo -e "${PATH//fu:/\\n}" | uniq | tr '\n' ':' | /usr/bin/sed 's/:$//')"

    { # SET PROMPT VARIABLE (PS1)

        if hostname | grep -q 'a2plcpnl0845';
        then
            if ((EUID == 0)); then
                # set root prompt
                export PS1=$'\[\e[41;37;1m\]\u@kenanigans:\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
            else
                #export PS1=$'[\[\e[46;37;1m\] \u@kenanigans \[\e[00;00;0m\]:\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
                export PS1=$'[\W]\$ ';
            fi
        else
            if ((EUID == 0)); then
                # set root prompt
                export PS1=$'\[\e[41;37;1m[\u]\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
            else
                #export PS1=$'[\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
                export PS1=$'[\W]\$ ';
            fi
        fi
    }

    { # SET PROMPT_COMMAND
    
        unset -f ps1_command

        function ps1_command() {
            local -ir xit=$?;

            if (( xit != 0 )); then
                builtin echo
                _err \
                    -h"ERROR (${xit}) [00;00;0m" \
                    "[31m[last_command]:[00m [40;33m $(history 1 | /usr/bin/sed 's:^[[:blank:]]*[0-9][0-9]*[[:blank:]]*\(.*$\):\1:') [00;00;0m";
                builtin echo
            fi
            return ${xit}
        }

        if ! builtin echo "${PROMPT_COMMAND}" | grep -q 'ps1_command'; then
            PROMPT_COMMAND='ps1_command'"${PROMPT_COMMAND:+";${PROMPT_COMMAND}"}"
        fi

    }

}

{ # USER ALIASES

    #shellcheck disable=2015
    if _isMac; then
        alias ls='ls -hGOU'
    else
        alias ls='ls --color=auto'
    fi

    if _isMac && command -v 'osascript' &> /dev/null; then
        alias scpt='osascript'
        alias scpthere='osascript <<!'
        alias scpth='osascript <<!'
    fi

    if [[ -x ~/bin/caffeinate ]]; then
        alias caff='caffeinate -f'
    fi

    alias dff='declare -f f 2> /dev/null'
    alias disks='/bin/df -PHl'

    alias h='history'
    alias j='jobs'

    alias la='ls -A'
    alias ll='ls -og'
    alias llt='ls -tog'
    alias lt='ls -t'
    alias lla='ls -ogA'
    alias l1='ls -1'
    alias lm='ls -m'
    alias l.='ls -d .[^$.]* 2> /dev/null'
    alias lt.='ls -dt .[^$.]* 2> /dev/null'
    alias ll.='ls -ogd .[^$.]* 2> /dev/null'
    alias l1.='ls -1d .[^$.]* 2> /dev/null'
    alias lm.='ls -md .[^$.]* 2> /dev/null'
    alias lll.='ls -ogdL .[^$.]* 2> /dev/null'

    if command -v git &> /dev/null; then
        alias gits='git s'
        if command -v git-cal &> /dev/null
        then
            gitcal () 
            { 
                /usr/bin/printf '\n%s\n%s\n\n' \
                    "$(/usr/bin/git cal | /usr/bin/sed -E '/(Total commits)/,$d')" \
                    "$(hr)"

                return
            }
        fi
    fi

    if [[ -x ~/bin/horizontal_rule ]]; then
        alias hr="\${HOME}/bin/horizontal_rule"
    fi

    alias c='clear'
    alias x='exit'
    alias sbash='[ -r ~/.bash_profile ] && . ~/.bash_profile'

    alias shutdown='sudo command shutdown -h now'
    alias shutdownh='sudo command shutdown -h now'
    alias shutdownr='sudo command shutdown -r now'

    if _isMac;
    then
        alias grep='/usr/bin/grep --color=auto'
        alias egrep='/usr/bin/egrep --color=auto'
        alias fgrep='/usr/bin/fgrep --color=auto'

        alias appstore='open -a "App Store"';


        if [[ -x "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport" ]]
        then
            alias airport='/System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport'
        fi
    elif [[ "$(uname)" == 'Linux' ]]
    then
        alias grep='/bin/grep --color=auto'
        alias egrep='/bin/egrep --color=auto'
        alias fgrep='/bin/fgrep --color=auto'
    fi


    #alias trunc='cut -c1-${COLUMNS:-$(tput cols)}';
    alias mkdir='mkdir -p'

    if [[ -x /Applications/GeekTool.app ]] && _isMac; then
        alias geektool='open -a "GeekTool"'
        function geeklets ()
        {
            osascript <<!
tell application "GeekTool Helper"
geeklets
end tell
!
            return
        }

        function geek ()
        {
            function _refresh_geektool ()
            {
                osascript <<!
tell application "GeekTool Helper" to refresh all
!
                return
            }

            function _open_geektool ()
            {
                open -a "GeekTool";
                return
            }

            function _list_all_geeklets ()
            {
                osascript <<! | /usr/bin/sed 's:,[[:blank:]]*:|:g' | tr '|' '\n'
tell application "GeekTool Helper" to geeklets
!
                return
            }

            function _list_geeklets ()
            {
                local OLDIFS; OLDIFS="$IFS"
                IFS=$'\n'
                trap 'IFS="$OLDIFS}";' RETURN;
                local -a allGeeklets
                mapfile allGeeklets < <(_list_all_geeklets)
                #allGeeklets=( $(_get_geeklets) )
                if (( ${#allGeeklets[@]} > 0 )); then
                    echo "GEEKLETS (${#allGeeklets[@]}):"
                    for ((c=0;c<${#allGeeklets[@]};c++)); do
                        #geekletID="$(echo "${allGeeklets[$c]}" | /usr/bin/sed 's:^.* ::')"
                        geekletID="${allGeeklets[${c}]%% }"
                        thisGeekletName="$(osascript -e "tell application \"GeekTool Helper\" to get name of geeklet id \"${geekletID}\"")"
                        #geekletReference="$(echo "${allGeeklets[$c]}" | /usr/bin/sed 's/^.* //')"
                        geekletReference="${allGeeklets[$c]##* }"
                        [[ "${thisGeekletName}" =~ (missing value) ]] \
                            && thisGeekletName="[no name]"
                        /usr/bin/printf '  - %s (id: %s)\n' "${thisGeekletName}" "${geekletReference}"
                    done
                else
                    echo "<< NO ACIVE GEEKLETS >>"
                    return
                fi
                return
            }

            local -i OPTIND; OPTIND=1
            while getopts :lro OPT; do
                case "${OPT}" in
                    r) _refresh_geektool; return;;
                    l) _list_geeklets; return;;
                    o) _open_geektool; return;;
                    *) _err "invalid flag -- ${OPTARG}";;
                esac
            done; shift $((OPTIND-1))
            if (( $# == 0 )); then
                _open_geektool
                return
            fi
            return
        }
    fi

}   # END USER ALIASES


f1 () {
    local OLDIFS; OLDIFS=$"${IFS}"
    IFS=$'\n'
    trap 'IFS=$"${OLDIFS}"; [[ "${OLDIFS}" != "${IFS}" ]] && _err "I broke the IFS variable"; return;' return HUP QUIT INT

    local target; local -a args
    target="${1:?}"; shift 1
    args=( [0]='-mindepth' [1]=1 [2]='-maxdepth' [3]=1 )
    args+=( "$@" )
    CMD="command find ${target}"
    for ((c=0;c<${#args[@]};c++)); do
        CMD+=" $(printf '%q' "${args[${c}]}")"
    done
    eval "${CMD}"
    return
}

#}

if declare -f hr &> /dev/null
then
    alias rtstr='hr -d" " -h';
    #alias rtdir='rtstr "$(echo "${PWD}" | /usr/bin/sed "s:^/:root->:" | /usr/bin/sed "s:root->${HOME#*/}/:home->:" | tr "/" "-")"';
    alias rtdir='rtstr "$(echo "${PWD}" | /usr/bin/sed "s:^/:root->:" | /usr/bin/sed "s:root->${HOME#*/}/:home->:" | tr "/" "-")"';
    alias rttime='rtstr "$(date +"%a %H:%M.%S")"';
    alias rtt='rtdir;rttime;';
    alias crtt='command clear && rtdir;rttime';
    #alias crttt='rtstr "$(echo "${PWD}" | /usr/bin/sed "s:^/:root->:" | /usr/bin/sed "s:root->${HOME#*/}/:🏡 ➡:" | tr "/" "-") | $(date +"%a %H:%M.%S")"'
    alias crttt='rtstr "$(echo -e "\\033[33;1m$(echo "${PWD}" | /usr/bin/sed "s:^/:root->:" | /usr/bin/sed "s:root->${HOME#*/}/:home->:" | tr "/" "-")\\033[00m \\033[1m|\\033[00m \\033[35;1m$(date +"%a %H:%M.%S")"\\033[00m)"'
fi

function funcs ()
{
    function _list_all_funcs ()
    {
        builtin declare -F | /usr/bin/cut -c12- | /usr/bin/sort | /usr/bin/column;
        return
    }

    function _list_func ()
    {
        #~/bin/horizontal_rule -h "START_FUNC: ${funcname}"
        /usr/bin/printf '\n\t> [40;33;1m FUNC: [00m [45;37;1m %s [00m\n\n' "${funcname}";
        /usr/bin/printf '%s\n' "${OUTPUT:?}"
        #printf '\n\t> [35;1mEND_FUNC:[00m [45;37;1m %s [00m\n\n' "${funcname}";
        ~/bin/horizontal_rule -h "END_FUNC: ${funcname}"
        return
    }

    function _list_func_definitions ()
    {
        for funcname in "$@"; do
            (( MORE_FLAG == 1 )) \
                && clear
            OUTPUT="$(declare -f "${funcname}")"
            if [[ -n "${OUTPUT:-}" ]]; then
                _list_func "${funcname}";
            else
                _err "function not defined: ${funcname}"
            fi
            (( MORE_FLAG == 1 )) \
                && read -rp "<CR> to continue..." REP
            echo "$REP" &> /dev/null
        done
        return
    }

    local MORE_FLAG; MORE_FLAG=0

    if (( $# == 0 )); then
        _list_all_funcs
    else
        _list_func_definitions "$@"
    fi
    return
}

aliases ()
{
    _list_defs () {
        /usr/bin/printf '\033[45;37;1m ALIAS DEFS: \033[00m\n%s\n%s\n' "$(alias | cut -d' ' -f2- | awk -F"=" '{printf ("%15s   => %s\n",$1,$2)}')" "$(hr -d '-')";
        return;
    }

    _list_names () {
        /usr/bin/printf '\033[45;37;1m ALIAS NAMES: \033[00m\n%s\n' "$(alias|cut -d' ' -f2- | /usr/bin/sed 's/=.*$//' | sort | column)";
        return;
    }

    _formatted_output () {
        hr;
        _list_defs;
        _list_names;
        hr -d '-';
        echo;
        return;
    }

    local -i OPTIND; OPTIND=1;
    while getopts :nda OPT;
    do
        case "${OPT}" in
            n) # list names
                hr;
                _list_names;
                hr;echo;
                return;
            ;;
            d) # list defs
                hr;
                _list_defs;
                echo;
                return;
            ;;
            a) # list both
                _formatted_output;
                return;
            ;;
            *) _err "invalid flag -- ${OPTARG}"
                return 11;
            ;;
        esac;
    done;
    shift $((OPTIND-1));

    _formatted_output;
    return;
}

#shellcheck disable=2120
#function trim () {
#    local INPUT;
#    if [[ -p /dev/stdin ]];
#    then
#        INPUT="$(cat /dev/stdin)";
#        [[ -z "${INPUT}" ]] && return 11;
#    elif (($#>0));
#    then
#        INPUT="${*:?ERROR, no input detected}";
#    fi
#
#    ## INPUT verified
#    local OUTPUT;
#    OUTPUT="$(builtin echo "${INPUT}" \
#        | /usr/bin/sed -E -e 's/^[[:blank:]]*//' \
#            -e 's/[[:blank:]]*$//')" \
#     || return 12;
#    [[ -z "${OUTPUT:-}" ]] && return 13;
#    builtin echo -e "${OUTPUT}";
#    return;
#}

#if declare -f trim &> /dev/null;
#then
#    alias lines='/usr/bin/wc -l | trim | tr -d "\n"'
#fi


if command -v shellcheck &> /dev/null;
then
    function sch () { 

        _list_level_output () {
            shellcheck -xa "${TARGET}" -f gcc -S "${l}" | grep -v '^[[:blank:]]*$'
            return
        }

        _check_file () {
            hr
            local TARGET; TARGET="${1:?no target file given}";
            #verify file exists and readable
            if [[ ! -e "${TARGET}" || ! -f "${TARGET}" || ! -r "${TARGET}" ]]; then
                _err "unable to find, access, or read specified target: ${TARGET}"
                return
            fi
            for l in "${LVL[@]}";
            do
                lvl_output="$(_list_level_output)";
                local -i output_count;
                #shellcheck disable=2126
                output_count=$(builtin echo "${lvl_output}" | grep -v '^[[:blank:]]*$' | wc -l | tr -dc '0-9');
                /usr/bin/printf '\t%8s: %s\n' "${l}" "${output_count}";
                if ! (( output_count == 0 )); then
                    builtin echo "${lvl_output}";
                fi;
            done;
            return;
            builtin echo;
            __build_hdr_str "ERROR";
            shellcheck -xa "${TARGET}" -f gcc -S error;
            __build_hdr_str "WARNING";
            shellcheck -xa "${TARGET}" -f gcc -S warning;
            __build_hdr_str "INFO";
            shellcheck -xa "${TARGET}" -f gcc -S info;
            __build_hdr_str "STYLE";
            shellcheck -xa "${TARGET}" -f gcc -S style;
            builtin echo;
            return;
        }

        (( $# == 0 )) && _err "no input files passed" && return 11

        for filename in "$@"; do
            _check_file "${filename}"
        done
    }
fi

function paths () {
    _output_path () {
        echo "PATH: ${PATH}"
        return
    }

    _raw_list () {
        builtin echo -e "${PATH//:/\\n}"
        return
    }

    _numbered_list () {
        _raw_list \
            | nl
        return
    }

    _list_verbose() {
        hr
        _output_path
        /usr/bin/printf '\n  %s:\n\n%s\n\n' \
            "PATHS" \
            "$(_numbered_list)"
        hr
        return
    }

    local -i OPTIND; OPTIND=1
    while getopts :rnbv OPT;
    do
        case "${OPT}" in
            v) #verbose
                _list_verbose
                return
            ;;
            b) #basic
                _output_path
                return
            ;;
            r) #list raw
                _raw_list
                return
            ;;
            n) #list numbered
                _numbered_list
                return
            ;;
            :)
                _err "flag requires an argument -- ${OPTARG}"
                return 1
            ;;
            *)
                _err "invalid flag -- ${OPTARG}"
                return 1
            ;;
        esac
    done
    shift $((OPTIND=1))

    #_numbered_list
    _list_verbose
    return
}

function clienv () {

    # handle option flags
    local -i OPTIND VERBOSITY;
    OPTIND=1; VERBOSITY=0;
    # -b: specify to list bash init files

    while getopts :bnav OPT;
    do
        case "${OPT}" in
            a)
                # list all src files
                find "$clienv/src" -type f \
                    | /usr/bin/sed 's/^.*\(clienv\)/\1/';
                return;
            ;;
            b)
                #shellcheck disable=2046,2086
                command grep '/usr/bin/env bash' $(find $clienv/src -type f) \
                    | /usr/bin/sed 's/^\(.*\):.*$/\1/' | sort | uniq \
                    | /usr/bin/sed 's/^.*\(clienv\)/\1/';
                return;
            ;;
            n)
                # list files not part of bash
                while IFS= read -r FILEPATH;
                do
                    if ! grep -q '/usr/bin/env bash' "${FILEPATH}";
                    then
                        echo "${FILEPATH}";
                    fi
                done < <(find "$clienv/src" -type f) \
                    | /usr/bin/sed 's/^.*\(clienv\)/\1/';
                return;
            ;;
            v)
                ((VERBOSITY++));
            ;;
            :)
                _err "option flag requires an argument -- \`${OPTARG}'";
            ;;
            *)
                _err "invalid flag -- ${OPTARG}";
            ;;
        esac
    done
    shift $((OPTIND-1));

    # validate location var
    [[ -z "${clienv:-}" ]] && return 11;
    [[ -d "${clienv}" ]] || return 12;

    if ! cd "${clienv}";
    then # ensure move into directory
        _err "unable to move to \${clienv} directory -- ${clienv}";
        return 13;
    fi;

    if (( VERBOSITY > 0 ));
    then
        { # output report
            hr -d'-';
            /usr/bin/printf '  => PWD: %s\n' "$PWD"
            if (( VERBOSITY > 1 ));
            then
                _msg "STATUS:";
                git status;
                hr;
            fi
            if (( VERBOSITY == 1 ));
            then
                hr -d'-';
                _msg "BRANCHES:";
                git branch -a;
                hr;
                _msg "REMOTES:";
                git remote -v;
                    hr;
            fi
        }
    fi

    return;
}

if _isMac; then
    function kenanigans () {
        ssh kenanigans
        return
    }
fi


if ! alias trunc &> /dev/null; then
    function trunc () {
        local INPUT;
        INPUT='';
        if [[ -p /dev/stdin ]];
        then
            INPUT="$(cat /dev/stdin)";
            [[ -z "${INPUT}" ]] && return 11;
        elif (($#>0));
        then
            INPUT="${*:?ERROR, no input detected}";
        fi

        ## INPUT verified
        local OUTPUT;
        OUTPUT="$(builtin echo "${INPUT}" | cut -c1-${COLUMNS:-$(tput cols)})"
        [[ -z "${OUTPUT:-}" ]] && return 13;
        builtin echo -e "${OUTPUT}";
        return;
    }
fi

if _isMac; then
    # make trash function

    dait ()
    {
        /bin/date +"%a-%b-%d %H:%M";
        return
    }

    daitstamp ()
    {
        /bin/date +"%a-%b-%d %H:%M";
        return
    }

    trash () {
        local TRASH_DIR
        TRASH_DIR=~/.Trash
        [[ ! -d "${TRASH_DIR}" ]] && return 202;

        _list_trash_directory_status () {
            local SIZE
            #shellcheck disable=2116
            SIZE="$(echo \
        "$(echo "scale=2; $(( $(du -s ~/Movies | tr -dc '0-9') * 512 ))/1000/1000" | bc) MB")";
            if [[ "${SIZE:0:1}" =~ ^\.$ ]]; then SIZE="0${SIZE}"; fi
            echo "TRASH SIZE: ${SIZE}"
            return
        }

        local -i OPTIND; OPTIND=1
        while getopts :s OPT; do
            case "${OPT}" in
                s)
                    _list_trash_directory_status
                    echo facek
                    return
                ;;
                *)
                    _err "invalid flag -- ${OPTARG}"
                ;;
            esac
        done

        _list_trash_directory_status

        return
    }

    beep () {
        local -i count; count=${1:-1}
        osascript -e "beep ${count}"
        return
    }

    
    if declare -f hr &> /dev/null
    then
        clearl ()
        {
            /usr/bin/clear;
            /usr/bin/printf '\n  PWD: %s\n  TIME: %s\n\n' "${PWD}" "$(date +"%a %H:%M.%S")";
            /bin/ls -hGTA;
            hr;
            echo;
            return
        }
        declare -f clearl &> /dev/null \
            && alias cl='clearl';
    fi

fi

function dir () 
{ 
    dirs -c
    dirs -c
    cd ~/Documents || return 42;
    pushd ~/Desktop &> /dev/null || return 43;
    pushd ~/Downloads &> /dev/null || return 44;
    if [[ -d ~/Library/Mobile\ Documents ]] && cd ~/Library/Mobile\ Documents &> /dev/null; then
        if ! pushd "${PWD}" &> /dev/null; then return 46; fi;
    fi;
    cd ~ &> /dev/null || return 45;
    echo "DIRS:"
    dirs -v \
        | /usr/bin/sed "s:\~:${HOME}:" \
        | /usr/bin/sed '/Mobile Documents/s:\(Mobile Documents\)[[:blank:]]*$:\1 (iCloud):';
    dirs -c
    dirs -c
    return
}

function aliases()
{
    /usr/bin/printf '\n  ALIASES:\n'
    alias \
        | /usr/bin/sed -E -e 's/^alias +//' -e 's/=.*$//' \
        | column
    /usr/bin/printf '\n'
    return
}

function vars ()
{
    function _print_raw_list () 
    { 
        { 
            set \
                | /usr/bin/sed -E -e '/^{/,$d' \
                | /usr/bin/sed -E -e '$d';
            env
        } \
            | sed -E -e 's|[[:cntrl:]]\[[0-9;]+m||g';
        return
    }

    function _print_raw_names_list ()
    {
        _print_raw_list \
            | sort -d \
            | awk -F"=" '{print $1}'
        return
    }

    function _list_out_var_names ()
    {
        /usr/bin/printf '\n  VARIABLES:\n\n';
        _print_raw_list \
            | awk -F"=" '{print $1}' \
            | grep -v '^_$' \
            | sort -d \
            | uniq \
            | grep -E -v -e '^[[:punct:][:blank:]]$' \
            | column;
        /usr/bin/printf '\n\n';
        return;
    }

    function _print_report ()
    {
        return
    }

    function _usage ()
    {
        local MSG
        MSG='\nUSAGE: vars -[rlfu]'
        local -a OPTS; OPTS=(
            'r|l:print output as single column'
            'f:print the var names in formatted columns'
            'u|h:print this usage statement'
        )
        MSG+='\nOPTION FLAGS:\n'
        for LINE in "${OPTS[@]}"; do
            OPTFLAG="${LINE%%:*}"
            OPTDEF="${LINE##*:}"
            MSG+="  -${OPTFLAG}: "
            MSG+="${OPTDEF}"
            MSG+='\n'
        done
        MSG+='\n'
        echo -ne "${MSG}"
        return
    }

    function _print_names_list ()
    {
        local -a VARNAMES;
        local -x OLDIFS; OLDIFS="${IFS}"
        [[ "${OLDIFS}" != "${IFS}" ]] && return 42;
        trap '[[ "${IFS}" != "${OLDIFS}" ]] && IFS="${OLDIFS}"; [[ "${IFS}" != "${OLDIFS}" ]] && _err "IFS ERR";' RETURN
        mapfile VARNAMES < <(_print_raw_names_list)
        for V in "${VARNAMES[@]}"; do
            echo "${V}" | grep -E -v '^[[:blank:]]*$';
        done
        return
    }

    local -i OPTIND; OPTIND=1
    while getopts :rlfuh OPT; do
        case "${OPT}" in
            f) _list_out_var_names; return;;
            l|r) _print_raw_list; return;;
            u|h) _usage; return;;
            :) _err "invalid flag -- ${OPTARG}";;
        esac
    done; shift $((OPTIND-1));

    # if no early return, then no opt flags were passed
    # remaining args should be seen as list of vars to print out

    if (( $# > 0 )); then
        for varname in "$@"; do
            local VALUE;
            VALUE="${!varname:-}"
            local VARNAMECOLOR;
            if [[ -z "${VALUE:-}" ]]; then
                VARNAMECOLOR='33;41';
                VALUE="[41;37;1m <NOT SET> [00m";
            else
                VARNAMECOLOR='32';
            fi
            /usr/bin/printf -- '-> [[%sm%s[00m]: %s\n' "${VARNAMECOLOR}" "${varname}" "${VALUE}"
        done
    fi
    return
}

dirr () 
{ 
    local TARGET;
    TARGET="${1:-"${PWD}"}";
    if [[ ! -d "${TARGET}" ]]; then
        _err;
        return 1;
    fi;
    find "${TARGET}" -maxdepth 1 -mindepth 1 -type d -exec du -s {} \; | sort -nr | awk -v TARGET="${TARGET}" -Ft 'BEGIN{printf ("\n\t ::: SIZE LISTING IN: %s :::\n\n",TARGET)} $1>0{UNIT="MB";VALUE=($1*512/1000/1000); if (VALUE>2000) { VALUE=(VALUE/1000); UNIT="GB"; }; /usr/bin/printf ("%10.2f %s: %s\n",VALUE,UNIT,$2)} END{printf ("\n\n")}' | /usr/bin/sed -e "s:${HOME}/:~/:" | /usr/bin/sed -E -e '4,$s|^(.*: )([[:print:]]*/)?([^/]+)$|\1\2[42;37;1m \3 [00m|';
    return
}

function lines ()
{
    local INPUT;
    INPUT='';
    
    # SET THE INPUT
    if [[ -z "${INPUT:-}" ]]; then
        if [[ -p /dev/stdin ]];
        then
            INPUT="$(cat /dev/stdin)";
            [[ -z "${INPUT}" ]] && return 11;
        elif (($#>0)); then
            INPUT="${*:?ERROR, no input detected}";
        elif [[ -n "$(pbpaste)" ]]; then
            INPUT="$(pbpaste)";
        fi
        [[ -z "${INPUT:-}" ]] && _err && return 12;
    fi

    local -i LINECOUNT
    LINECOUNT=$(echo "${INPUT}" \
        | wc -l \
        | trim)
    ((LINECOUNT--))

    echo "LINES: ${LINECOUNT}"
    #echo "INPUT:"
    #echo "${INPUT}"

    return
}

function chars ()
{
    local INPUT;
    INPUT='';

    local -i OPTIND
    while getopts :p OPT; do
        case "${OPT}" in
            p) INPUT="$(pbpaste)";;
            *) _err "invalid flag -- ${OPTARG}";;
        esac
    done
    shift $((OPTIND-1))

    if [[ -z "${INPUT:-}" ]]; then
        if [[ -p /dev/stdin ]];
        then
            INPUT="$(cat /dev/stdin)";
            [[ -z "${INPUT}" ]] && return 11;
        elif (($#>0)); then
            INPUT="${*:?ERROR, no input detected}";
        elif [[ -n "$(pbpaste)" ]]; then
            INPUT="$(pbpaste)";
        fi
        [[ -z "${INPUT:-}" ]] && _err && return 12;
    fi

    local -i CHARCOUNT
    CHARCOUNT=$(echo "${INPUT}" \
        | wc -c \
        | trim)
    ((CHARCOUNT--))

    echo "CHARACTERS: ${CHARCOUNT}"
    #echo "INPUT:"
    #echo "${INPUT}"
    return
}

function brewupdate ()
{
    local -a CMDS;
    CMDS=( "brew update" "brew upgrade" "brew upgrade --cask" "brew doctor" );
    for CMD in "${CMDS[@]}"; do
        ~/bin/horizontal_rule -h "EXE: ${CMD}";
        eval "${CMD}";
    done
    ~/bin/horizontal_rule;
    return;
}

function pull_repos () 
{ 
    function _find_git_dirs ()
    {
        find "${TARGET}" -type d -name ".git" -exec dirname {} \;
        return
    }

    local -a visited_repos
    visited_repos=()

    local TARGET;
    TARGET="${1:-"${dev:?}"}";
    while IFS=$'\n' read -r REPO_DIR; do
        BN="$(basename "${REPO_DIR}")"
        if ! cd "${REPO_DIR}"; then
            _err;
            continue;
        fi;
        ~/bin/horizontal_rule -h "${BN}";
        if ! git pull 2> /dev/null; then
            /usr/bin/printf '>> [NO UPDATES]\n';
        fi

        visited_repos+=( "${BN}" );

        if ! cd ~-; then
            _err;
            break;
        fi;
    done \
        < <(_find_git_dirs);
    ~/bin/horizontal_rule;
    /usr/bin/printf '>> visited [%d] repos...\n' ${#visited_repos[@]};
    echo "(${visited_repos[*]})"
    ~/bin/horizontal_rule;
    return
}


function update ()
{
    #shellcheck disable=2069
    _get_update_list () { sudo softwareupdate --list --all 2>&1 1> /dev/null; return; }

    function _brewupdate ()
    {
        local -a CMDS;
        CMDS=("brew update" "brew upgrade" "brew upgrade --cask" "brew doctor");
        for CMD in "${CMDS[@]}";
        do
            ~/bin/horizontal_rule -h "EXE: ${CMD}";
            eval "${CMD}";
        done;
        ~/bin/horizontal_rule;
        return
    }


    function _software_update ()
    {
        hr -h "EXE: sudo softwareupdate --list --all"
        local OUTPUT
        OUTPUT="$(_get_update_list)"

        if [[ "$OUTPUT" == 'No new software available.' ]]; then
            echo "<< NO UPDATES AVAILABLE >>"
            return
        else
            echo "UPDATES:"
            echo "${OUTPUT}"
            return
        fi

        return
    }

    _software_update
    _brewupdate
    return
}

function loggr () 
{ 
    function _is_loggr_already_running ()
    {
        /bin/ps -jp "$(\
            /bin/ps -opid,ppid,command \
                | /usr/bin/grep "${HOME}/.fifo" \
                | grep -v "$$" \
                | cut -d' ' -f1-2 \
                | /usr/bin/sed -e 's/^.* //' \
                | /usr/bin/sed -n '2p' \
                | tr -d '\n')"
        return
    }

    function break_fifo ()
    {
        if [[ -p ~/.fifo ]]; then
            /usr/bin/printf '[loggr]: %s\n' "ending \`loggr' session"
            echo "BREAK" >> ~/.fifo
            return
        else
            _err
            return 42
        fi
        return
    }

    local -i OPTIND
    OPTIND=1

    while getopts :b OPT; do
        case "${OPT}" in
            b)
                # break
                break_fifo
                return
                ;;
            *)
                _err "invalid flag -- ${OPTARG}"
                ;;
        esac
    done
    shift $((OPTIND-1))

    declare -i BREAK_FLAG;
    BREAK_FLAG=0;
    local FIFO_FILE;
    FIFO_FILE="${HOME}/.fifo";
    [[ -e "$FIFO_FILE" ]] && rm "$FIFO_FILE";

    mkfifo "$FIFO_FILE";
    if [[ ! -p ~/.fifo ]];then
        echo "NO PIPE ${FIFO_FILE}"
        return
    fi

    while ((BREAK_FLAG != 1)); do
        while IFS= read -r LINE; do
            CMD="${LINE%% *}";
            if [[ "${CMD}" =~ (break|BREAK) ]]; then
                BREAK_FLAG=1;
            fi;
            /usr/bin/printf '[%s]: %s\n' "$(date +"%a %H:%M")" "${LINE}";
            ((BREAK_FLAG==1)) && /usr/bin/printf '\n\t>> got the BREAK flag. exiting.\n\n';
        done < <(cat ~/.fifo);
    done;
    return
}

function update ()
{
    _get_update_list () { sudo softwareupdate --list --all 2>&1 > /dev/null; return; }

    function _brewupdate ()
    {
        local -a CMDS;
        CMDS=("brew update" "brew upgrade" "brew upgrade --cask" "brew doctor");
        for CMD in "${CMDS[@]}";
        do
            ~/bin/horizontal_rule -h "EXE: ${CMD}";
            eval "${CMD}";
        done;
        ~/bin/horizontal_rule;
        return
    }


    function _software_update ()
    {
        hr -h "EXE: sudo softwareupdate --list --all"
        local OUTPUT
        OUTPUT="$(_get_update_list)"

        if [[ "$OUTPUT" == 'No new software available.' ]]; then
            echo "<< NO UPDATES AVAILABLE >>"
            return
        else
            echo "UPDATES:"
            echo "${OUTPUT}"
            return
        fi

        return
    }

    _software_update
    _brewupdate
    return
}

if [[ -n "${_location_variables[@]:0:1}" ]]; then
    function locations ()
    {
        printf '\n  [LOCATIONS:]\n\n'
        for LOC_KEY in "${!_location_variables[@]}"; do
            printf '  %*s -> %s\n' -30 "[${LOC_KEY}]" "${_location_variables[${LOC_KEY}]}";
        done
        echo
        return
    }
fi

if command -v brew &> /dev/null; then
    function br ()
    {
        function _list_command ()
        {
            local -l list_target
            list_target="${OPTARG:0:1}"
            case "${list_target}" in
                f)
                    printf '\n  [HOMEBREW FORMULAS]:\n'
                    brew list -1 --formula
                    return
                    ;;
                c)
                    printf '\n  [HOMEBREW CASKS]:\n'
                    brew list -1 --cask
                    return
                    ;;
                b)
                    printf '%s\n  [%s]:\n%s\n\n' \
                        "$(hr)" "FORMULAS" "$(brew list -1 --formula)" \
                        "$(hr)" "CASKS" "$(brew list -1 --cask)"
                    hr
                    return
                    ;;
                *)
                    _err "argument to the \`l' flag -- ${OPTARG}"
                    ;;
            esac
            return
        }

        function _case_opt_flags ()
        {
            case "${OPT}" in
                l)
                    # if passed with argument, then
                    #   - argument should specify listing one of:
                    #       - formulas
                    #       - casks
                    #       - both
                    _list_command
                    return $?
                    ;;
                :)
                    _err "flag requires an argument -- \`-${OPTARG}'"
                    ;;
                *) _err "invalid flag -- ${OPTARG}";;
            esac
            return
        }

        function _prompt_user_action_selection ()
        {
            select action in "update "{formulas,casks} "search "{formulas,casks} abort; do
                if [[ -z "${action:-}" && -n "${REPLY:-}" ]]; then
                    action="${REPLY}"
                else
                    _err "no action was specified";
                    return 42;
                fi
                printf '\n\t[selected action]: %s\n\n' "${action}"
                break
            done
            printf '\tExiting...\n'
            return
        }

        #_print_raw_list
        local -i OPTIND; OPTIND=1
        while getopts :l: OPT; do
            _case_opt_flags
        done;
        shift $((OPTIND-1))

        _prompt_user_action_selection

        printf '\tExiting...\n'
        return 0
    }
fi

#vim: fdm=indent
