# ~/.bashrc
# shellcheck shell=bash

{ # helper variables and functions

    [[ ! -e ~/.hushlogin ]] && builtin echo -n > ~/.hushlogin

    export CLR_SUCCESS_HEADER=$'\033[42;37;1m'
    CLR_MSG_HEADER=$'\033[40;33;1m'
    CLR_MSG_TXT=$'\033[35;1m'
    export CLR_ERR_HEADER=$'\033[41;37;1m'
    export CLR_ERR_TXT=$'\033[31;1m'
    export CLR_RST=$'\033[00m'

    if [[ -z "${DEBUG_LEVEL:-}" ]]; then
        declare -ix DEBUG_LEVEL
        DEBUG_LEVEL=-2
    fi
    (( DEBUG_LEVEL > -2 )) && printf '[DEBUG_LEVEL: %d]\n' "${DEBUG_LEVEL}"

    function _err () {
        local -i OPTIND; OPTIND=1
        local headerStr; headerStr='ERROR';
        while getopts :h: OPT; do
            case "${OPT}" in
                h) headerStr="${OPTARG}";;
                :) _err "flag requires an argument -- \`${OPTARG}'";;
                *) _err "invalid option flag -- \`${OPTARG}'";;
            esac
        done
        shift $((OPTIND-1));

        local msg header;
        msg="${*:-"an unspecified error occurred"}";
        header=" ${headerStr} ";
        printf ' %s%s%s %s%s%s\n' \
            "${CLR_ERR_HEADER}" \
            "${header}" \
            "${CLR_RST}" \
            "${CLR_ERR_TXT}" \
            "${msg}" \
            "${CLR_RST}" >&2;
        return 0
    }

    function _msg () {
        local -i leadingLine trailingLine OPTIND;
        OPTIND=1
        leadingLine=0;  # will prepend line if == 1
        trailingLine=0;  # will append line if == 1

        # handle options
        while getopts :l: OPT;
        do
            case "${OPT}" in
                l)
                    # lines
                    case "${OPTARG}" in
                        p|pre|prepend) leadingLine=1;;
                        a|append) trailingLine=1;;
                        b|both) leadingLine=1; trailingLine=1;;
                        *) return 222;;
                    esac
                ;;
                :)
                    echo FUCK;
                    case "${OPTARG}" in
                        l)
                            # `l' flag without arguments: assume both is specified
                            leadingLine=1; trailingLine=1;
                        ;;
                        *) return 223;;
                    esac
                ;;
                *)
                ;;
            esac
        done
        shift $((OPTIND-1));

        local msg header headerStr;
        headerStr="[clienv]"
        msg="${*:?}";
        header="${headerStr}";
        local OUTPUT;
        OUTPUT='';
        OUTPUT+="${CLR_MSG_HEADER} ${header} ${CLR_RST}";
        OUTPUT+="${CLR_MSG_TXT} ${msg} ${CLR_RST}";

        if (( leadingLine ==1 ))
        then OUTPUT='\n'"${OUTPUT}";
        fi

        if (( trailingLine ==1 ))
        then OUTPUT+='\n'
        fi

        #printf '  %s %s %s: %s%s%s\n' \
            #"${CLR_MSG_HEADER}" "${header}" "${CLR_RST}" \
            #"${CLR_MSG_TXT}" "${msg}" "${CLR_RST}" >&2;

        echo -e "${OUTPUT:?"ERR"}"
        return 0
    }

    function _success () {
        local msg header;
        msg="${*:?}";
        header="SUCCESS";
        printf '  %s[ %s ]%s: %s\n' "${CLR_SUCCESS_HEADER}" "${header}" "${CLR_RST}" "${msg}" >&2;
        return 0
    }
    function _isMac () { if [[ "$(uname)" == 'Darwin' ]]; then return 0; fi; return 1; }
    function _hasCommand () { local TARGET; TARGET="${1:?}"; if command -v "${TARGET}" &> /dev/null; then return 0; fi; return 1; }

    if _isMac && _hasCommand system_profiler; then
        function _sysinfo () 
        { 
            local -i DEBUG; DEBUG=0;
            if [[ "${1:-}" =~ (-|--)?(D|DEBUG|debug)$ ]];
            then
                DEBUG=1; shift 1;
            fi;
            tmpfile="$(mktemp)";
            builtin trap '(( DEBUG == 1 )) && /usr/bin/printf "removing temp file (${tmpfile})... "; if /bin/rm "${tmpfile}"; then (( DEBUG == 1 )) && /bin/echo SUCCESS; else (( DEBUG == 1 )) && /bin/echo FAILED; fi;' RETURN;
            (( DEBUG == 1 )) && /usr/bin/printf '\n  > [DEBUG]: TEMPFILE -- %s\n\n' "${tmpfile}";
            /usr/sbin/system_profiler -detailLevel mini -xml SPSoftwareDataType > "${tmpfile}";
            /usr/bin/plutil -p "${tmpfile}" | /usr/bin/sed -n '/^[[:blank:]]*"_name"/,/^[[:blank:]]*"uptime"/p' | /usr/bin/tr -d '"' | /usr/bin/sed 's/^[[:blank:]][[:blank:]]*_*\([^[:blank:]]*\)  *=>  *\(.*$\)/\1|\2/' | /usr/bin/awk -F"|" 'BEGIN{printf "\nSYSTEM INFO:\n"}{printf ("- %*s %s\n",-15,$1":",$2)}';
            builtin echo;
            return
        }
    fi
}

{ # ENVIRONMENTAL VARIABLES
    _isMac && export GLOBIGNORE=.DS_Store:.CFUserTextEncoding:.localized:.hushlogin
    export CDPATH=.:~
    export LSCOLORS=$'Dxfxcxdxbxegedabagacad';      # default =. 'exfxcxdxbxegedabagacad'
    export HISTFILE=~/.bash_history
    export HISTFILESIZE=100000
    export HISTSIZE=100000
    export HISTCONTROL='ignoreboth'
    export MYSQL_HISTFILE=~/.mysql_history
    export LESSHISTFILE=~/.less_history
    export LESSHISTSIZE=10000
    export EDITOR='vim'

    if [[ -d /usr/local/sbin ]] \
        && ! builtin echo "$PATH" | grep -q "/usr/local/sbin"
    then
        export PATH="${PATH:+"${PATH}:"}/usr/local/sbin"
    fi

    if [[ -d "${HOME}/bin" ]] \
        && ! builtin echo "${PATH}" |  grep -q "${HOME}/bin"
    then
        export PATH="${HOME}/bin${PATH:+":${PATH}"}"
    fi

    { # SET PROMPT VARIABLE (PS1)

        if hostname | grep -q 'a2plcpnl0845';
        then
            if ((EUID == 0)); then
                # set root prompt
                export PS1=$'\[\e[41;37;1m\]\u@kenanigans:\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
            else
                export PS1=$'[\[\e[46;37;1m\] \u@kenanigans \[\e[00;00;0m\]:\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
            fi
        else
            if ((EUID == 0)); then
                # set root prompt
                export PS1=$'\[\e[41;37;1m[\u]\W\[\e[00;00;0m\]-\[\e[40;36;1m\]\#\[\e[00;00;0m\]\$ '
            else
                export PS1=$'[\[\e[40;33;1m\]\W\[\e[00;00;0m\]] \e[40;36;1m\]\#\[\e[00;00;0m\] \$ '
            fi
        fi
    }

    { # SET PROMPT_COMMAND
    
        unset -f ps1_command

        function ps1_command() {
            local -ir xit=$?;

            echo "\"\${xit}\"=${xit:-"(NULL)"}";
            if (( xit != 0 )); then
                builtin echo
                _err \
                    -h"ERROR (${xit}) [00;00;0m" \
                    "[31m[last_command]:[00m [40;33m $(history 1 | sed 's:^[[:blank:]]*[0-9][0-9]*[[:blank:]]*\(.*$\):\1:') [00;00;0m";
                builtin echo
            fi
            return ${xit}
        }

        if ! builtin echo "${PROMPT_COMMAND}" | grep -q 'ps1_command'; then
            PROMPT_COMMAND='ps1_command'"${PROMPT_COMMAND:+";${PROMPT_COMMAND}"}"
        fi

    }

    { # LOCATION VARIABLES
        if [[ -n "${_location_variables[*]}" ]]; then
            # unset all location variables
            for key in "${!_location_variables[@]}"; do
                unset "${key}"
            done
        fi
        unset _location_variables
        
        declare -A _location_variables; _location_variables=()
        declare -A _location_variable_errors; _location_variable_errors=()

        function validateAndSetLocationVariables() {
            local NAME DIR;
            NAME="${1:?}" DIR="${2:?}"
            if [[ ! -d "${DIR}" ]]; then
                _location_variable_errors["${NAME}"]="${DIR}"
                (( DEBUG_LEVEL >= -1 )) && _err "unable to set variable. directory not found -- ${DIR}"
                return 1
            fi
            if [[ -n "${!NAME}" ]]; then
                _location_variable_errors["${NAME}"]="${DIR}"
                (( DEBUG_LEVEL >= 0 )) && _err "name has already been set previously -- ${!NAME}"
                return 2
            fi
            eval "${NAME}=\"${DIR}\""
            if [[ -n "${!NAME}" && "${!NAME}" == "${DIR}" ]]; then
                _location_variables["${NAME}"]="${DIR}"
                (( DEBUG_LEVEL == 1 )) && _success "${NAME} => ${!NAME}"
            fi
        }

        { # set location variables here
            (( DEBUG_LEVEL >= 0 )) && printf '\n  [%s] => %s\n\n' 'clienv' 'setting location variables';
            if _isMac; then
                validateAndSetLocationVariables "clienv" ~/Desktop/clienv
                validateAndSetLocationVariables "dev" ~/Developer
                validateAndSetLocationVariables "repos" ~/Developer/repos
                validateAndSetLocationVariables "desk" ~/Desktop
                validateAndSetLocationVariables "docs" ~/Documentssssss
                validateAndSetLocationVariables "dl" ~/Downloads
                validateAndSetLocationVariables "sites" ~/Sites
                validateAndSetLocationVariables "favs" ~/Library/Favorites/
                validateAndSetLocationVariables "proj" ~/Projects
                validateAndSetLocationVariables "var" /private/var
                validateAndSetLocationVariables "etc" /private/etc
                if [[ -d /usr/local ]];
                then
                    validateAndSetLocationVariables "uvar" /usr/local/var
                    validateAndSetLocationVariables "uetc" /usr/local/etc
                    validateAndSetLocationVariables "uetc2" /usr/local/etcc
                    validateAndSetLocationVariables "uetc" /usr/local/
                fi
            elif [[ "$(uname)" == 'Linux' ]]
            then
                validateAndSetLocationVariables "repos" ~/repos
                validateAndSetLocationVariables "clienv" ~/repos/clienv
                validateAndSetLocationVariables "www" ~/public_html
            fi
        }

	shopt -s cdable_vars

        if (( ${#_location_variable_errors[@]} > 0 )); then
            (( DEBUG_LEVEL >= 0 )) && _err "location variable assignment errors occurred (${#_location_variable_errors[@]})"
        fi
        
        # clean up
        unset -f validateAndSetLocationVariables
        unset _location_variable_errors
    }
}

{ # USER ALIASES

    #shellcheck disable=2015
    _isMac && alias ls='ls -hGTtx' || alias ls='ls --color=auto'

    alias la='ls -A'
    alias ll='ls -og'
    alias lla='ls -ogA'
    alias l1='ls -1'
    alias lm='ls -m'
    alias l.='ls -d .[^$.]* 2> /dev/null'
    alias ll.='ls -ogd .[^$.]* 2> /dev/null'
    alias l1.='ls -1d .[^$.]* 2> /dev/null'
    alias lm.='ls -md .[^$.]* 2> /dev/null'

    alias c='clear'
    alias x='exit'
    alias sbash='[ -r ~/.bash_profile ] && . ~/.bash_profile'

    if _isMac;
    then
        alias grep='/usr/bin/grep --color=auto'
        alias egrep='/usr/bin/egrep --color=auto'
        alias fgrep='/usr/bin/fgrep --color=auto'
    elif [[ "$(uname)" == 'Linux' ]]
    then
        alias grep='/bin/grep --color=auto'
        alias egrep='/bin/egrep --color=auto'
        alias fgrep='/bin/fgrep --color=auto'
    fi

    alias mkdir='mkdir -p'

}


f1 () {
    target="${1:?}"; shift 1
    local -a args
    args=([0]='-mindepth' [1]=1 [2]='-maxdepth' [3]=1)
    args+=( "$@" )
    CMD="command find ${target}"
    for ((c=0;c<${#args[@]};c++)); do
        CMD+=" $(printf '%q' "${args[${c}]}")"
    done
    #builtin echo "CMD: ${CMD}"
    eval "${CMD}"
    return
}

function hr () {
    local -i OPTIND rtstrlength; OPTIND=1; rtstrlength=4
    local -i col; col=${COLUMNS:-$(tput cols)}
    local hrstr delim headertext; hrstr=''; delim='_'; headertext='';
    (( ${#delim} > 1 )) && delim="${delim:0:1}"
    while getopts :d:h:PD OPT
    do
        case "${OPT}" in
            d) delim="${OPTARG:0:1}"
            ;;
            D)
                # include date
                headertext="$(date +"%a %H:%M")"
            ;;
            P)
                # include $PWD
                headertext="${PWD}"
            ;;
            h) headertext="${OPTARG}"
            ;;
            :) _err "flag requires an argument -- ${OPTARG}"
            ;;
            *) _err "invalid option flag -- ${OPTARG}"
            ;;
        esac
    done; shift $((OPTIND-1))
    local text; text=''
    if [[ -z "${headertext:-}" ]]; then
        if (( $# > 0 )) ; then
            text="${*}";
        fi
    else
        text="${headertext}"
    fi
    (( ${#text} > col )) && { _err; return 2; }
    for (( c = 0; c < $(( col - ${#text} - $((rtstrlength+2)) )); c++ )); do
        hrstr="${hrstr}${delim}"
    done
    if [[ -n "${text:-}" ]]; then hrstr+="[${text}]"
    else hrstr+="${delim}${delim}"
    fi
    for (( a = 0; a < rtstrlength; a++ )); do
        hrstr+="${delim}"
    done
    (( ${#hrstr} != col )) && { _err; return 1; }
    printf '%s\n' "${hrstr}"
    return
}

function funcs () {

    #shellcheck disable=2207
    declare -F | sed -E 's/^declare -[a-z0-1A-Z]+ //' | sort | grep -v '^shell_session_'
    mapfile FUNCNAMES < <(declare -F | sed -E 's/^declare -[a-z0-1A-Z]+ //' | sort | grep -v '^shell_session_');
    mapfile sysfuncnames < <(builtin echo "${FUNCNAMES[@]}" | xargs -n1  builtin echo | grep '^_');
    mapfile userfuncnames < <(builtin echo "${FUNCNAMES[@]}" | xargs -n1  builtin echo | grep -v '^_');

    hr -d'-'
    {
        builtin echo -e "\\n\\033[46;37;1m FUNCTIONS: \\033[00;00;0m";
        builtin echo -e "\\n[36m sys:[00m\\n${sysfuncnames[*]}";
        builtin echo -e "\\n[36m user:[00m";
        builtin echo "${userfuncnames[@]}" | xargs -n1 echo | nl \
            | trim \
            | tr '\t' ' ' | tr -s ' ';
        builtin echo;
    } \
        | sed -E -e 's/^/   /';
    hr -d'-';
    return;
}

#shellcheck disable=2120
function trim () {
    local INPUT;
    if [[ -p /dev/stdin ]];
    then
        INPUT="$(cat /dev/stdin)";
        [[ -z "${INPUT}" ]] && return 11;
    elif (($#>0));
    then
        INPUT="${*:?ERROR, no input detected}";
    fi

    ## INPUT verified
    local OUTPUT;
    OUTPUT="$(builtin echo "${INPUT}" \
        | sed -E -e 's/^[[:blank:]]*//' \
            -e 's/[[:blank:]]*$//')" \
     || return 12;
    [[ -z "${OUTPUT:-}" ]] && return 13;
    builtin echo -e "${OUTPUT}";
    return;
}

if command -v shellcheck &> /dev/null;
then
    function sch () { 
        local TARGET;
        TARGET="${1:?no target file given}";
        local -a LVL;
        LVL=('error' 'warning' 'info' 'style');
        for l in "${LVL[@]}";
        do
            lvl_output="$(shellcheck -xa "${TARGET}" -f gcc -S "${l}" | grep -v '^[[:blank:]]*$')";
            local -i output_count;
            #shellcheck disable=2126
            output_count=$(builtin echo "${lvl_output}" | grep -v '^[[:blank:]]*$' | wc -l | tr -dc '0-9');
            printf '\t%8s: %s\n' "${l}" "${output_count}";
            if ! (( output_count == 0 )); then
                builtin echo "${lvl_output}";
            fi;
        done;
        return;
        builtin echo;
        __build_hdr_str "ERROR";
        shellcheck -xa "${TARGET}" -f gcc -S error;
        __build_hdr_str "WARNING";
        shellcheck -xa "${TARGET}" -f gcc -S warning;
        __build_hdr_str "INFO";
        shellcheck -xa "${TARGET}" -f gcc -S info;
        __build_hdr_str "STYLE";
        shellcheck -xa "${TARGET}" -f gcc -S style;
        builtin echo;
        return;
    }
fi

function paths () {
    builtin echo -e "${PATH//:/\\n}" \
        | nl
    return
}
